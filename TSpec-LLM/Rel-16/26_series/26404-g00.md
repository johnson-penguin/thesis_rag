![](media/image1.jpeg){width="7.086111111111111in"
height="1.136111111111111in"}

Contents {#contents .TT}
========

[4](#foreword)

[5](#scope)

[5](#normative-references)

[5](#definitions-symbols-and-abbreviations)

[5](#definitions)

[6](#symbols)

[7](#abbreviations)

[7](#outline-description)

[7](#sbr-encoder-description)

[7](#sbr-tools-overview)

[8](#enhanced-aacplus-sdynchronization-without-parametric-stereo)

[9](#enhanced-aacplus-synchronisation-with-parametric-stereo)

[10](#sbr-encoder-modules-overview)

[12](#analysis-filterbank)

[15](#frequency-band-tables)

[15](#time-frequency-grid-generation)

[15](#transient-detector)

[16](#frame-splitter)

[17](#frame-generator)

[21](#envelope-estimation)

[22](#additional-control-parameters)

[22](#introduction)

[23](#tonality-estimation)

[24](#noise-floor-estimation)

[25](#inverse-filtering-estimation)

[26](#additional-sines-estimation)

[29](#data-quantization)

[30](#envelope-and-noise-floor-coding)

[32](#bitstream)

[34](#annex-a-informative-change-history)Foreword 1 Scope 2 Normative
references 3 Definitions, symbols and abbreviations 3.1 Definitions 3.2
Symbols 3.3 Abbreviations 4 Outline description 5 SBR encoder
description 5.1 SBR tools overview 5.1.1 Enhanced aacPlus
sdynchronization without parametric stereo 5.1.2 Enhanced aacPlus
synchronisation with parametric stereo 5.1.3 SBR encoder modules
overview 5.2 Analysis filterbank 5.3 Frequency band tables 5.4 Time /
frequency grid generation 5.4.1 Transient detector 5.4.2 Frame splitter
5.4.3 Frame generator 5.5 Envelope estimation 5.6 Additional control
parameters 5.6.1 Introduction 5.6.2 Tonality estimation 5.6.3
Noise-floor estimation 5.6.4 Inverse filtering estimation 5.6.5
Additional sines estimation 5.7 Data quantization 5.8 Envelope and noise
floor coding 6 Bitstream Annex A (informative): Change history

Foreword
========

The present document describes the detailed mapping of the general audio
service employing the aacPlus general audio codec within the 3GPP
system.

The contents of the present document are subject to continuing work
within the TSG and may change following formal TSG approval. Should the
TSG modify the contents of this TS, it will be re-released by the TSG
with an identifying change of release date and an increase in version
number as follows:

Version x.y.z

where:

x the first digit:

1 presented to TSG for information;

2 presented to TSG for approval;

3 Indicates TSG approved document under change control.

y the second digit is incremented for all changes of substance, i.e.
technical enhancements, corrections, updates, etc.

z the third digit is incremented when editorial only changes have been
incorporated in the specification;

1 Scope
=======

This Telecommunication Standard (TS) describes the SBR encoder part of
the Enhanced aacPlus general audio codec \[3\].

2 Normative references
======================

This TS incorporates by dated and undated reference, provisions from
other publications. These normative references are cited in the
appropriate places in the text and the publications are listed
hereafter. For dated references, subsequent amendments to or revisions
of any of these publications apply to this TS only when incorporated in
it by amendment or revision. For undated references, the latest edition
of the publication referred to applies.

\[1\] ISO/IEC 14496-3:2001/Amd.1:2003, Bandwidth Extension.

\[2\] ISO/IEC 14496-3:2001/Amd.1:2003/DCOR1.

\[3\] 3GPP TS 26.401 : Enhanced aacPlus general audio codec; General
Description

3 Definitions, symbols and abbreviations
========================================

3.1 Definitions
---------------

For the purposes of this TS, the following definitions apply:

**band:** (as in limiter band, noise floor band, etc.) a group of
consecutive QMF subbands

**chirp factor:** the bandwidth expansion factor of the formants
described by a LPC polynomial

**Down Sampled SBR:** the SBR Tool with a modified synthesis filterbank
resulting in a down sampled output signal with the same sample rate as
the input signal to the SBR Tool. May be used whenever a lower sample
rate output is desired.

**envelope scalefactor:** an element representing the averaged energy of
a signal over a region described by a frequency band and a time segment

**frequency band:** interval in frequency, group of consecutive QMF
subbands

**frequency border:** frequency band delimiter, expressed as a specific
QMF subband

**noise floor:** a vector of noise floor scalefactors

**noise floor scalefactor:** an element associated with a region
described by a frequency band and a time segment, representing the ratio
between the energy of the noise to be added to the envelope adjusted HF
generated signal and the energy of the same

**patch:** a number of adjoining QMF subbands moved to a different
frequency location

**SBR envelope:** a vector of envelope scalefactors

**SBR frame:** time segment associated with one SBR extension data
element

**SBR range:** the frequency range of the signal generated by the SBR
algorithm

**subband:** a frequency range represented by one row in a QMF matrix,
carrying a subsampled signal

**time border:** time segment delimiter, expressed as a specific time
slot

**time segment:** interval in time, group of consecutive time slots

**time / frequency grid:** a description of SBR envelope time segments
and associated frequency resolution tables as well as description of
noise floor time segments

**time slot:** finest resolution in time for SBR envelopes and noise
floors. One time slot equals two subsamples in the QMF domain

3.2 Symbols
-----------

For the purposes of this TS, the following symbols apply:

Description of variables defined in one sub clause and used in other
subclasses.

*ch* is the current channel, and when used as index in vectors left
channel is represented by *ch*= 0 and right channel is represented *ch*=
1.

**E***~Orig~* has *L~E~* columns where each column is of length *N~Low~*
or *N~High~* depending on the frequency resolution for each SBR
envelope. The elements in **E***~Orig~* contains the envelope
scalefactors of the original signal.

![](media/image3.wmf){width="1.3465277777777778in"
height="0.2916666666666667in"} has two column vectors containing the
frequency border tables for low and high frequency resolution.

![](media/image4.wmf){width="0.375in" height="0.2222222222222222in"}
internal sampling frequency of the SBR Tool, twice the sampling
frequency of the core coder (after sampling frequency mapping, Table
4.55). The sampling frequency of the SBR enhanced output signal is equal
to the internal sampling frequency of the SBR Tool, unless the SBR Tool
is operated in downsampled mode. If the SBR Tool is operated in
downsampled mode, the output sampling frequency is equal to the sampling
frequency of the core coder.

**f***~Master~* is of length *N~Master~*+1 and contains QMF master
frequency grouping information.

**f***~TableHigh~* is of length *N~High~*+1 and contains frequency
borders for high frequency resolution SBR envelopes.

**f***~TableLow~* is of length *N~Low~*+1 and contains frequency borders
for low frequency resolution SBR envelopes.

**f***~TableNoise~* is of length *N~Q~*+1 and contains frequency borders
used by noise floors.

*k~x~* the first QMF subband in the SBR range.

*k~0~* the first QMF subband in the **f***~Master~* table.

*L~E~* number of SBR envelopes.

*L~Q~* number of noise floors.

*M* number of QMF subbands in the SBR range.

*middleBorder* points to a specific time border.

*N~L~* number of limiter bands.

*N~Master~* number of frequency bands in the master frequency resolution
table.

*N~Q~* number of noise floor bands.

![](media/image5.wmf){width="1.0277777777777777in" height="0.25in"}
number of frequency bands for low and high frequency resolution.

*numPatches* a variable indicating the number of patches in the SBR
range.

*numTimeSlots* number of SBR envelope time slots that exist within an
AAC frame, 16 for a 1024 AAC frame .

![](media/image6.wmf){width="1.2916666666666667in" height="0.25in"}
offset-values for the SBR envelope and noise floor data, when using
coupled channels.

**patchBorders** a vector containing the frequency borders of the
patches.

**patchNumSubbands** a vector holding the number of subbands in every
patch.

**Q***~Orig~* has *L~Q~* columns where each column is of length *N~Q~*
and contains the noise floor scalefactors.

![](media/image7.wmf){width="0.8888888888888888in"
height="0.2222222222222222in"} frequency resolution for all SBR
envelopes in the current SBR frame, zero for low resolution, one for
high resolution.

*reset* a variable in the encoder and the decoder set to one if certain
bitstream elements have changed from the previous SBR frame, otherwise
set to zero.

**t***~E~* is of length *L~E~*+1 and contains start and stop time
borders for all SBR envelopes in the current SBR frame.

*t~HFAdj~* offset for the envelope adjuster module.

*t~HFGen~* offset for the HF-generation module.

**t***~Q~* is of length *L~Q~*+1 and contains start and stop time
borders for all noise floors in the current SBR frame.

3.3 Abbreviations
-----------------

For the purposes of this TS, the following abbreviations apply.

> NA Not Applicable
>
> aacPlus Combination of MPEG-4 AAC and MPEG-4 Bandwidth extension (SBR)
>
> Enhanced aacPlus Combination of MPEG-4 AAC, MPEG-4 Bandwidth extension
> (SBR) and MPEG-4 Parametric Stereo
>
> QMF Quadrature Mirror Filter
>
> SBR Spectral Band Replication

4 Outline description
=====================

This TS is structured as follows:

Section 5.1 gives an encoder overview description. Section 5.2 gives a
detailed description of the filterbanks used in the encoder. Section 5.3
gives a specification of the used frequency band tables. Section 5.4
gives a detailed description of the time grid calculation and the
transient detection. Section 5.5 gives a detailed description of the
envelope estimation. Section 5.6 gives a detailed description of the
estimation of the additional control parameters. Section 5.7 gives
detailed description of the data quantisation. Section 5.8 gives a
detailed description of the envelope coding.

5 SBR encoder description
=========================

5.1 SBR tools overview
----------------------

The encoder part of the SBR tool estimates several parameters used by
the high frequency reconstruction method on the decoder side. In order
to synchronise the SBR bitstream data with the AAC codec, the two
different modes of operation have to be considered; normal aacPlus
operation and aacPlus parametric stereo operation. In the normal case,
the AAC encoder is responsible for downsampling of the input PCM signal,
while the SBR encoder works in parallel on twice the sampling frequency
compared to the downsampled signal. When using parametric stereo
aacPlus, the SBR tool is also responsible for downsampling of the AAC
coder signal. The two modes are outlined in the following sections and
illustrated in Figure 1 and Figure 2.

![](media/image8.wmf){width="6.0375in" height="1.8097222222222222in"}

Figure 1 aacPlus block diagram

![](media/image9.wmf){width="5.149305555555555in"
height="1.895138888888889in"}

Figure 2 Parametric stereo aacPlus block diagram

### 5.1.1 Enhanced aacPlus sdynchronization without parametric stereo

The time domain input PCM signal is assumed to be stored in a buffer
**x**, where 2048 new samples are added to the end of the buffer every
frame. Before adding new samples, all samples in the buffer must be
left-shifted 2048 samples. The buffersize amounts to 576 + 2048 +
*t*~inputDelay~ samples, where *t*~inputDelay~ equals the total AAC
delay, i.e. the delay for the entire encoder -- decoder chain, plus the
SBR decoder buffer delay minus the SBR encoder buffer delay. All delays
are expressed in the SBR input sampling rate:

![](media/image10.wmf){width="3.44375in" height="0.25in"}

The PCM buffer **x** is fed to the analysis QMF bank, where subband
filtering is performed. The window stride of the QMF bank is illustrated
in Figure 3a, which shows that the first window is applied from sample 0
to sample 639 on the PCM buffer. The output from the analysis QMF bank:
32 subbands having 64 frequency channels each, is stored in the matrix
**X** (Figure 3b) as

![](media/image11.wmf){width="4.25in" height="0.20833333333333334in"}

A delay of qmfWriteOffset subband samples is hence introduced, making

![](media/image12.wmf){width="1.8333333333333333in"
height="0.20833333333333334in"}

The algorithmic buffer delay in the decoder is 6 subband samples, giving

![](media/image13.wmf){width="1.75in" height="0.20833333333333334in"}

The total AAC delay is the delay introduced by the 1024 point MDCT
transform, the window switching look-ahead and the delay introduced by
the downsampling filter. If other delays are introduced these of course
have to be accounted for.

![](media/image14.wmf){width="6.690277777777778in"
height="3.9159722222222224in"}

Figure 3 aacPlus encoder buffers and synchronisation

### 5.1.2 Enhanced aacPlus synchronisation with parametric stereo

The time domain input PCM signal is assumed to be stored in a buffer
**x**, where 2048 new samples are added to the end of the buffer every
frame. Before adding new samples, all samples in the buffer must be
left-shifted 2048 samples. The buffersize amounts to 576 + 2048. Note
that two buffers are needed for stereo signals.

The PCM buffer is fed to the analysis QMF bank, where subband filtering
is performed. The window stride of the QMF bank is illustrated in Figure
4a, which shows that the first window is applied from sample 0 to sample
639 on the PCM buffer. The output from the analysis QMF bank: 32
subbands having 64 frequency channels each, is stored in the matrix
**H** (Figure 4b) as

![](media/image15.wmf){width="3.486111111111111in" height="0.25in"}

Two buffers are needed for stereo operation. The subband samples in the
matrix **H** are fed to the hybrid filter bank (See \[5\]) which
introduces a delay of 6 subband samples. Parametric stereo parameters
are extracted from the output of the hybrid filterbank and downmixing of
the stereo signal is performed. Subsequently, hybrid synthesis filtering
is applied to the modified hybrid subband samples.

The downmixed subband samples are fed to the subband matrix **X**
(Figure 4c) as

![](media/image16.wmf){width="4.333333333333333in" height="0.25in"}

whereafter \"normal\" SBR operation is undertaken. The subband samples
are in parallell fed to the 32 channel synthesis filter bank. The stride
for the synthesis windowing is illustrated in Figure 4d. The output from
the filterbank, having a sampling frequency half of the SBR sampling
frequency is forwarded to the AAC encoder.

After SBR processing of the current frame, an additional delay of one
frame has to be introduced by delaying the SBR frame data (Figure 4e).

To achieve synchronisation, the total AAC codec delay is bound to be
3200 samples, expressed in the SBR input sampling frequency.

![](media/image17.wmf){width="6.690277777777778in"
height="8.343055555555555in"}

Figure 4 Enhanced aacPlus stereo synchronisation

### 5.1.3 SBR encoder modules overview

The modules of the encoder part of the SBR tool are illustrated in the
block diagram of Figure 5. The SBR tool operates on discrete mono
signals in general, but some of the modules in Figure 5 need
simultaneous access to both the left and right signal in case of stereo
signals.

\- As outlined in 5.1.1 and 5.1.2, the time domain signal is first
filtered by the 64 channel complex QMF bank (section 5.2). The output
from the analysis QMF bank: 32 subbands having 64 frequency channels
each, is stored in the matrix **X** as\
\
![](media/image18.wmf){width="4.291666666666667in" height="0.25in"}\
\
Several modules use the output from the QMF bank;

\- The transient detector operates on the matrix **X** starting at
subband sample 0.

\- The frame splitter operates on the matrix **X** starting at subband
sample 0.

\- The output from the transient detector and frame splitter is fed to
the frame generator, where the time and frequency resolutions for the
current frame are determined.

\- The Tonality detector operates on the matrix **X** starting at
subband sample qmfWriteOffset.

\- The control data from the Tonality detector and also the current time
and frequency grid is forwarded to the unit for Additional control
parameters. In this module, the levels of the adaptive noise, inverse
filtering and additional sines are determined.

\- The Envelope energy formatter operates on the matrix **X** starting
from subband sample 0. The unit needs the time frequency grid and the
additional control data as inputs.

\- The formatted envelope data is subsequently quantised and Huffman
coded, before being fed to the Bitstream multiplexer, where all SBR data
is formatted and packed into a SBR frame. The SBR frame is transmitted
as a fill-element in the bitstream multiplex together with the AAC
channel element for the current frame. In case of a Parametric stereo
SBR element, the current SBR frame is delayed one frame before entering
the bitstream multiplexer (Section 5.1.2 ).

![](media/image19.wmf){width="7.027777777777778in"
height="4.936111111111111in"}

Figure 5 Sbr Encoder overview

5.2 Analysis filterbank
-----------------------

Subband filtering of the input signal is done by a 64-subband QMF bank.
The output from the filterbank, i.e. the subband samples, are
complex-valued and thus oversampled by a factor two compared to a
regular QMF bank. The flowchart of this operation is given in Figure 6.
The filtering comprises the following steps, where an array **x**
consisting of 640 time domain input samples are assumed. Higher indices
into the array corresponds to older samples:

\- Shift the samples in the array **x** by 64 positions. The oldest 64
samples are discarded and 64 new samples are stored in positions 0 to
63.

\- Multiply the samples of array **x** by window **c**. The window
coefficients are found in Figure 6.

\- Sum the samples according to the formula in the flowchart to create
the 128-element array **u**.

\- Build two arrays, **r** and **i**, from **u** by the operations

![](media/image20.wmf){width="2.3465277777777778in"
height="0.4722222222222222in"}

\- Calculate 64 new complex-valued subband samples, **X** = **R** + i
**I**, where i is the imaginary unit, by DCT and DST type III
transforming **r** and **i** according to

![](media/image21.wmf){width="2.9166666666666665in" height="0.94375in"}

Every loop in the flowchart produces 64 complex-valued subband samples,
each representing the output from one filterbank subband. For every SBR
frame the filterbank will produce
![](media/image22.wmf){width="1.3888888888888888in"
height="0.18055555555555555in"} subband samples from every filterbank
subband, corresponding to a time domain signal of length
![](media/image23.wmf){width="1.6111111111111112in"
height="0.18055555555555555in"} samples. In the flowchart
**X**\[k\]\[l\] corresponds to subband sample l in QMF subband k.

![](media/image24.wmf){width="4.604166666666667in"
height="9.136111111111111in"}

Figure 6: Flowchart of encoder analysis QMF bank

5.3 Frequency band tables
-------------------------

The SBR encoder use these different frequency band
tables:![](media/image25.wmf){width="0.3611111111111111in"
height="0.2222222222222222in"},
![](media/image26.wmf){width="0.4861111111111111in" height="0.25in"},
![](media/image27.wmf){width="0.4583333333333333in"
height="0.2222222222222222in"} and ![](media/image28.wmf){width="0.5in"
height="0.2222222222222222in"}, which are defined according to subclause
4.6.18.3.2 in \[1\]. The parameters needed to define all frequency band
tables are transmitted in the SBR bitstream header. For SBR header
bitstream elements enabled with either **bs\_header\_extra\_1** or
**bs\_header\_extra\_1** there are default values and hence a
transmission of these elements are only needed if they differ from the
default value. Default values are defined in subclause 4.5.2.8.1 in
\[1\]. The SBR header parameters are regarded as tuning parameters since
they are strongly bitrate and sampling frequency dependant Throughout
the tuning work for 3GPP submission several bitrate and sampling
frequency dependant tunings have been created and in the reference
c-code there are tunings available from 8kbit/s mono to 48 kbit/s
stereo.

5.4 Time / frequency grid generation
------------------------------------

An introduction to the time / frequency grid generation, including a
brief discussion of the frame classes, is given in the informal encoder
description in \[1\], subclause 4.B.18.3. The present encoder
implementation employs three tools for the grid generation:

\- The Transient Detector (TD)

\- The Frame Splitter (FS)

\- The Frame Generator (FG)

Those tools are described in the subsequent sections. Figure 7 shows the
ranges of the frame classes and the transient detector offset versus the
indices used by the frame generator.

\|\<\-\-\-\-\-\-\-\-\-\-\--tranPos\-\-\-\-\-\-\-\-\--\>\|

\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|

0 1 2 3 4 5 6 7 8 9 A B C D E F TD index (hexadecimal)

\|\<\-\-\-\-\-\-\-\-\-\-\--FIXFIX\-\-\-\-\-\-\-\-\-\--\>\|

\|\<\-\-\-\-\-\-\-\-\-\-\--FIXVAR\-\-\-\-\-\-\-\-\-\--\>:\<\-\--\>:

:\<\-\--\>:\<\-\-\-\-\--VARFIX\-\-\-\-\-\-\-\-\-\--\>\|

:\<\-\--\>:\<\-\-\-\-\--VARVAR\-\-\-\-\-\-\-\-\-\--\>:\<\-\--\>: Ybuffer

\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\....
QMF slots

I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-Io\|o\|o\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I
SBR slots

0 4 8 16 19 32 FG index

I: nominal frame boundaries

o: frame overlap region slots

Figure 7: The four frame classes and the transient detector range

### 5.4.1 Transient detector

The transient detection is performed according to the pseudo-code below.
It operates on subband samples of one frame length starting from sample
8. The output from the transient detector are the variables tranFlag and
tranPos. The first is a boolean indicating whether there is a transient
in the processed frame, and the second specifies the position (in time
slots) for the on-set of the transient. The time / frequency grid
generation module uses the output from the transient detector and the
stored transient detection output from the previous frame to perform its
operations.

![](media/image29.wmf){width="1.5965277777777778in"
height="1.0138888888888888in"}

![](media/image30.wmf){width="5.19375in" height="3.875in"}

![](media/image31.wmf){width="3.4583333333333335in"
height="2.2916666666666665in"}

**t** and **a** are static channel-dependent arrays of length 64 that
needs to be stored in between calls to the transient detector. On
start-up, all elements in both arrays must be set to zero.

### 5.4.2 Frame splitter

The frame splitting is accomplished according to the following
algorithm. It is only active when the transient detector has detected
the absence of a transient in the current frame of interest, i.e. when
tranFlag = 0). It operates on subband samples of one and a half frame
length starting from subband sample 0. The output from the frame
splitter is the variable splitFlag, which indicates whether the current
frame (free from transients) should be divided into two envelopes of
equal size.

![](media/image32.wmf){width="4.736111111111111in"
height="4.638888888888889in"}

The variable ![](media/image33.wmf){width="0.4305555555555556in"
height="0.25in"} is a static channel-dependent variable that must be
stored in between calls to the frame splitting module. This variable
should be set to zero on start-up.

### 5.4.3 Frame generator

The frame generator creates the time/frequency grid for one SBR frame.
Input signals are provided by the transient detector and the frame
splitter. The frame generator produces two outputs: The sbr\_grid()
portion of the bitstream, and an internal representation of the
time/frequency grid to be used by the envelope and noise floor
estimators, see Figure 5.

When no transients are present (i.e. tranFlag = 0), FIXFIX class frames
are used. The frame splitter decides whether to use one or two envelopes
in the FIXFIX frames (splitFlag = 0 or splitFlag = 1 respectively).
\"Sparse\" transients (separated by one or more frames with tranFlag =
0) are coded by means of FIXVAR-VARFIX sequences. \"Tight\" transients (
tranFlag = 1 for two or more consecutive frames) are handeled by
inserting VARVAR class frames.

As most transients are \"sparse\", the frame generator prepares a grid
for a FIXVAR-VARFIX pair upon detection of a transient after a sequence
of FIXFIX frames. The present frame is encoded using the FIXVAR portion,
and the VARFIX grid is stored. At the next call of the generator it is
known whether the transient actually is \"sparse\" or not. If \'yes\',
the already calculated and stored VARFIX grid is used. If \'no\', a new
grid, meeting the requirements of the new transient, as well as those of
the previous one, is calculated, whereby a VARVAR class frame is used.

The operation of the frame generator is further described below by means
of pseudo-code, where the syntax

\[*out*~0~, *out*~1~, \..., *out*~m-1~\] = *function*(*in*~0~, *in*~1~,
\..., *in*~n-1~) is used.

FrameGenerator(tranFlag, tranPos, splitFlag)

{

static frameClassOld; // frameClass used for previous frame

static G1; // grid designed during previous call

\[frameClass, frameClassOld\] = calcFrameClass(frameClassOld, tranFlag);

if (tranFlag)

GP = fillFrameTran(tranPos); // load transient borders into GP

switch (frameClass) {

case FIXFIX:

BS = calcSbrGrid(FIXFIX, dc, splitFlag);

break;

case FIXVAR:

if (tranPos \> 8)

GP = fillFramePre(GP); // append borders before transient borders

if (tranPos \< 10)

GP = fillFramePost(GP); // append borders after transient borders

\[G0, G1\] = splitAndStore(GP); // split GP into two grids, G0 and G1

BS = calcSbrGrid(FIXVAR, G0, dc); // calc BS using G0

break;

case VARFIX:

BS = calcSbrGrid(VARFIX, G1, dc); // calc BS using G1 (from previous
call)

break;

case VARVAR:

GP = fillFrameInter(G1, GP); // resolve conflicts and merge G1 and GP

if (tranPos \< 10)

GP = fillFramePost(GP); // append fill-borders after tran-borders in GP

\[G0, G1\] = splitAndStore(GP); // split GP into two grids, G0 and G1

BS = calcSbrGrid(VARVAR, G0, dc); // calc BS using newly designed G0

break;

}

return \[BS, FI = decodeSbrGrid(BS)\];// decode BS into FI

}

The following pseudo-variables are defined:

GP = \"Grid-Pair\":

\- GP.aBorders: array holding envelope borders of two consecutive frames

\- GP.aFreqRes: array holding envelope frequency resolutions of two
consecutive frames

\- GP.iTran : index of transient leading border

G*i* = \"Grid instance *i*\":

\- G*i*.aBorders: array holding envelope borders of one frame

\- G*i*.aFreqRes: array holding envelope frequency resolutions of one
frame

\- G*i*.iTran : index of transient leading border of one frame

BS = \"Bit-Stream\":

\- sbr\_grid() as defined in \[1\] Subclause 4.4.2.8, Table 4.61A

FI = \"Frame-Info\":

\- FI.t\_E: **t***~E~* , envelope borders as defined in 3.2

\- FI.r : , envelope frequency resolutions as defined in 3.2

\- FI.t\_Q: **t***~Q~* , noise floor borders as defined in 3.2

\- FI.l\_A: *l*~A~ , index of border where the preceding envelope is to
be \"shortened\"

the symbolic constant,

dc: don\'t care

and the operations

cat(a, b): concatenate vectors a & b

length(a): number of elements of vector a

fliplr(a): reverse order of elements of vector a

ones(a) : generate vector of length a, were all elements are 1

The internal functions are defined below:

calcFrameClass (frameClassOld, tranFlag)

{

switch (frameClassOld) {

case FIXFIX:

if (tranFlag)

frameClass = FIXVAR;// stationary to transient transition

else

frameClass = FIXFIX;// when no transients are present, FIXFIX frames are
used

break;

case FIXVAR:

if (tranFlag)

frameClass = VARVAR;// \"tight\" transients are handeled by VARVAR
frames

else

frameClass = VARFIX;// \"sparse\" transients are handeled by \[FIXVAR,
VARFIX\] pairs

break;

case VARFIX:

if (tranFlag)

frameClass = FIXVAR;

else

frameClass = FIXFIX;// transient to stationary transition

break;

case VARVAR:

if (tranFlag)

frameClass = VARVAR;// \"tight\" transients are handeled by VARVAR
frames

else

frameClass = VARFIX;

break;

}

frameClassOld = frameClass;

return \[frameClass, frameClassOld\];

}

fillFrameTran(tranPos)

{

GP.aBorders = {tranPos + 4, tranPos + 6, tranPos + 10};

GP.aFreqRes = {0, 0, 1};

GP.iTran = 0;

return GP;

}

fillFramePre(GP)

{

aBordersFill = fillHelper(GP.aBorders\[0\], 8);

GP.aBorders = cat(fliplr(aBordersFill), GP.aBorders);

GP.aFreqRes = cat(ones(length(aBordersFill)), GP.aFreqRes);

GP.iTran += length(aBordersFill);

return GP;

}

fillFramePost(GP, tranPos)

{

if (tranPos \< 4)

maxStep = 6;

else if (tranPos == 4 \|\| tranPos == 5)

maxStep = 4;

else

maxStep = 8;

aBordersFill = fillHelper((32 - GP.aBorders\[length(GP.aBorders) - 1\],
maxStep);

GP.aBorders = cat(GP.aBorders, aBordersFill);

GP.aFreqRes = cat(GP.aFreqRes, ones(length(aBordersFill)));

return GP;

}

splitAndStore(GP)

{

iSplit = 0;

while (GP.aBorders\[iSplit\] \< 16)

iSplit++;

for (i = 0; i \<= iSplit; i++) {

G0.aBorders\[i\] = GP.aBorders\[i\];

G0.aFreqRes\[i\] = GP.aFreqRes\[i\];

}

G0.iTran = GP.iTran;

for (j = 0, i = iSplit; i \< length(GP.aBorders); i++, j++) {

G1.aBorders\[j\] = GP.aBorders\[i\] - 16;

G1.aFreqRes\[j\] = GP.aFreqRes\[i\];

}

G1.iTran = GP.iTran - iSplit;

}

As evident from the pseudo code, every transient is initially processed
by fillFrameTran() by inserting one border at the onset of the
transient, and two \"decay\" borders after the onset at the distances 2
and 6 slots from the first border respectively. The frequency
resolutions of the two corresponding envelopes are \'low\', whereas all
other envelopes use \'high\' resolution. Additional borders are inserted
before said borders by fillFramePre() and fillFramePost(), such that no
envelope exceeds the length 12 slots. The function fillHelper(A, B)
subdivides the distance A by calculating segments quantized to the
lengths {2, 4, 6, 8} slots while limiting the segment length to B. In
splitAndStore() the borders are separated into two groups, each
associated with one frame. The above procedures are illustrated by
Figure 8.

tranFlag = 1

tranPos = 9

\<T\>

\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|

0 1 2 3 4 5 6 7 8 9 A B C D E F TD index

\*

\|\<\-\-\-\--6\-\-\--\|\<-2\|\<\--4\-\--\|\-\-\-\--6\-\-\--\>\|

N \| N

\|\<\-\-\-\-\-\-\-\-- Frame n: FIXVAR \-\-\--:\--3-\>\|\<\-- Frame n+1:
VARFIX \--\>\|

\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\....
QMF slots

I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-Io\|o\|o\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I
SBR slots

0 7 13 15 19 25 32 FG index

I: nominal frame boundaries

o: frame overlap region slots

\*: border pointed to by bs\_pointer

N: noise floor middle border

Figure 8: Example of isolated transient

In Figure 8. the borders at index 7, 13, 15 and 19 are used for the
present FIXVAR class frame. Conversion into sbr\_grid() bitstream
elements is performed in calcSbrGrid(). The methods of the four classes
for conversion of borders and frequency resolutions are implicitely
defined by the bitstream and decoding equations in \[1\], subclause
4.4.2.8 (Table 4.61A) and 4.6.18.3, and are hence not described here. In
the example bs\_var\_bord\_1 = 3, bs\_num\_rel\_1 = 3, the relative
borders have the lengths 4, 2 and 6 (\"right to left\"), and the
frequency resolutions are 0, 0, 1, 1 (\"right to left\"). The
bs\_pointer is set to point to the transient leading border, i.e. the
value is 3 since FIXVAR borders are also indexed \"right to left\",
starting from 1 (0 signals that no transient leading border is present
within the frame). The border at index 19 must be followed up in the
next frame by a leading border at index 3. The border at 25, however,
may or may not yield a border at 9, since a transient is possible in
frame n + 1. If the transient actually is \"sparse\", the VARFIX
bitstream comprises of bs\_var\_bord\_0 = 3, bs\_num\_rel\_0 = 1, one
relative border of length 6, bs\_pointer = 0 and frequency resolutions
1, 1.

Figure 9. gives an example of \"tight\" transients, and also serves to
outline the functionality of fillFrameInter(). Here G1 contains borders
at index 1 and 7, but a transient is located already at index 6. In
fillFrameInter() the preliminary border at 7 is simply removed, and the
rest of the borders for the present frame are taken from GP. (If on the
other hand the distance between the last border in G1 and the first
border in GP exceeds 12, the segment inbetween said borders is
subdivided analogously to the procedures in fillFramePre().) Hereafter
GP is finalized and split in the same manner as described above,
whereafter G0 is converted into a bitstream using the VARVAR method of
calcSbrGrid(). Hereby the leading border yields bs\_var\_bord\_0 = 1 and
the trailing border bs\_var\_bord\_1 = 2. Clearly bs\_num\_rel\_0 = 0
and bs\_num\_rel\_1 = 3. Figure 9. also shows that fillFramePost() has
inserted a border at 18, thereby meeting the requirement that one border
is present within the interval \[16, 19\]. This concludes the
description of how to generate BS.

tranFlag = 1

tranPos = 2

\<T\>

I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I

0 1 2 3 4 5 6 7 8 9 A B C D E F TD index

\*

\|\<r2\|\<\--r4\--\|\<\-\-\--6\-\-\-\--\|\-\-\-\--6\-\-\--\>\|

:1\| \| \|

:1\|\<\-\-\-\-\-\-- Frame n: VARVAR \-\-\--:2-\>\|\<\-\-- Frame n+1:
VARFIX \-\--\>\|

\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\....
QMF slots

I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-Io\|o\|oI-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I
SBR slots

0 1 6 7 8 12 18 24 32 FG index

Figure 9: Example of tight transients

The second output of the frame generator, FI, comprises of **t***~E~*,
**r**, **t***~Q~* and *l*~A~. Since those signals are equivalent to
their counterparts at the decoder side, the relation between FI and BS
is fully defined by the decoding equations in MPEG-4. Thus, as the last
step in the frame generator, the decodeSbrGrid() function parses and
decodes the now available sbr\_grid() portion of the bitstream in
accordance with the description in the MPEG-4 standard, which shall not
be repeated here.

5.5 Envelope estimation
-----------------------

By using the time/frequency grid created by the framing generator and
the transient information from the transient detector, the QMF bank
subband matrix is grouped in time and frequency into envelope
scalefactorbands. For each scalefactorband the squared average energy is
calculated and stored in the energy matrix according to the recursion
below.

![](media/image36.wmf){width="3.8465277777777778in"
height="3.0965277777777778in"}

If a missing harmonic has been detected in a certain scalefactorband the
squared energy for that scalefatorband is calculated as the maximum
energy instead of average energy. Since the missing harmonics detection
and signalling always operate using the recursion shown below.

![](media/image37.wmf){width="4.527777777777778in"
height="4.138888888888889in"}

For stereo with no channel coupling, the energy for every channel is
calculated as in the mono case shown above. In the case of stereo and
coupling the energy is calculated according to:

![](media/image38.wmf){width="4.333333333333333in"
height="0.4305555555555556in"}

![](media/image39.wmf){width="3.861111111111111in"
height="0.4861111111111111in"}

5.6 Additional control parameters
---------------------------------

### 5.6.1 Introduction

In order to achieve optimal results, given the HF generator used in the
decoder, several additional parameters apart from the spectral envelope
are assessed. The noise floor is estimated for the current SBR frame. It
is defined as the ratio between the energy of the noise that should be
added to a particular frequency band, in order to obtain a similar tonal
to noise ratio to that of the original signal, and the energy of the HF
generated signal for that frequency band.

The noise floor is estimated once or twice per SBR frame dependent on
the number of spectral envelopes estimated for the SBR frame (indicated
by ![](media/image40.wmf){width="0.18055555555555555in"
height="0.25in"}). The frequency resolution for the noise floor
scalefactor is calculated according to the same algorithm subsequently
used in the decoder and described in \[1\] subclause 4.6.18.3. The start
and stop time borders of the different noise floors are given from the
time grid.

The level of the inverse filtering applied in the decoder is estimated
for different frequency ranges with the same frequency resolution as
used for the noise floor scalefactor estimation. The estimation
algorithm compares the tonality of the original and the tonality that
will be attained after the HF generator in the decoder. The ratio
between the two is mapped to four different inverse filtering levels,
off, low, mid and high. These levels corresponds to different chirp
factors in the HF generator as outlined in \[1\] subclause 4.6.18.5.
Moreover, the encoder assesses where a strong tonal component will be
missing after the HF generation in the decoder. This detection is done
on the highest frequency resolution given by the high frequency
resolution table, **f***~TableHigh~*. The level of the tonal component
is implicitly coded by the SBR envelope and the noise floor
scalefactors, and thus only the frequency needs to be coded.

5.6.2 Tonality estimation
-------------------------

The following detection modules base their output on a tonality estimate
calculated in the tonality estimation module:

\- Noise-floor estimation

\- Inverse filtering estimation

\- Additional sines estimation

The tonality is derived from the prediction gain of a second order
linear prediction performed in every QMF subband. The LPC is calculated
using the covariance method, and for every frame two tonality estimates
are calculated for every subband.

In the following, **X** is the matrix holding the most recently
available complex QMF subband samples. The tonality values are
calculated and stored in the **T** and **Tsbr** matrices. These also
contain buffered values from previous frames. The **Tsbr** values are
obtained from the **T** values by patching the tonality values similarly
to the patching of the subband channels in the high frequency
reconstruction modules in the decoder.

Since the subband signals are complex valued, this results in complex
filter coefficients for the linear prediction. The prediction filter
coefficients are obtained from the covariance method. The covariance
matrix elements for every tonality estimate calculated are:

![](media/image41.wmf){width="4.541666666666667in"
height="0.4722222222222222in"}

where *k* is the subband index, and *l* is the tonality estimate.

Based on the covariance elements the coefficients
![](media/image42.wmf){width="0.4166666666666667in" height="0.25in"}and
![](media/image43.wmf){width="0.4166666666666667in" height="0.25in"}used
to calculate the tonality estimates for the subbands are calculated as:

![](media/image44.wmf){width="2.8194444444444446in" height="0.44375in"},

![](media/image45.wmf){width="3.7777777777777777in" height="0.75in"},

![](media/image46.wmf){width="3.2777777777777777in"
height="0.7638888888888888in"}.

where *~Inv~* is the relaxation parameter ( *~Inv~* = 1E-6 ).

The tonality values are calculated based on the above coefficients
according to:

![](media/image47.wmf){width="4.125in" height="0.5555555555555556in"}

![](media/image48.wmf){width="1.8611111111111112in"
height="0.6111111111111112in"}

The tonality values are patched similarly to the patching of the QMF
subbands in the decoder during high frequency reconstruction. Hence, it
is possible to compare tonality of a \"simulated\" SBR signal and the
original signal on the encoder side. The patch used is built in
accordance to the flowchart in Figure 4.46, subclause 4.6.18.6.3 in
\[1\], where the output variable *numPatches* is an integer value
specifying the number of patches. **patchStartSubband** and
**patchNumSubbands** are vectors holding the data output from the patch
decision algorithm.

Hence, the tonality values for the SBR part is obtained according to:

![](media/image49.wmf){width="1.7777777777777777in" height="0.25in"}

![](media/image50.wmf){width="2.5965277777777778in"
height="0.7222222222222222in"}

for ![](media/image51.wmf){width="4.055555555555555in" height="0.25in"}.

### 5.6.3 Noise-floor estimation

The noise floor estimation module estimates the amount of noise relative
to the energy of the patched SBR signal that should be added on the
decoder side in order to obtain a tonal to noise ratio similar to that
of the original. The estimation is based on the tonality values in the
**T** and **Tsbr** matrices, and the estimation is done for the number
of frequency bands indicated by *N~Q~* , and the frequency ranges
defined in **f***~TableNoise~* for the time segments defined by
![](media/image40.wmf){width="0.18055555555555555in" height="0.25in"}.
The algorithm below is outlined for noise floor band *nfBand* for noise
floor *nfEnv* and should be applied for all noise-floor bands, and noise
floors in the present frame. If the number of spectral envelopes for the
present frame is larger than one, two noise floors will be estimated,
otherwise one. For the case of two noise floors *startIndex* will be
zero for the first noise-floor and one for the second noise-floor, while
*stopIndex* will be one for the first noise-floor, and two for the
second noise-floor. In case of only one noise-floor, the *startIndex*
will be zero and the *stopIndex* will be one.

The noise floor is calculated by averaging of the tonality values for
the given time/frequency range, or by choosing the maximum tonality
value. The latter is used if the additional sine detection algorithm
detects that a sine should be added on the decoder side for frequency
band that is included in the present noise floor frequency band.

Hence, for every noise floor band the tonality values are calculated
according to:

![](media/image52.wmf){width="4.819444444444445in"
height="0.7638888888888888in"}

![](media/image53.wmf){width="5.027777777777778in"
height="0.7638888888888888in"}

or, if a sine will be added at the decoder side as indicated by
\"missingHarmonicsFlag\", according to:

> ![](media/image54.wmf){width="6.596527777777778in"
> height="0.3055555555555556in"}![](media/image55.wmf){width="7.027777777777778in"
> height="0.3055555555555556in"}

The tonality values *Tavg* and *TavgSbr* are subsequently used to
calculate the actual noise-floor value, according to:

![](media/image56.wmf){width="3.4583333333333335in"
height="0.4722222222222222in"},

if the additional sine detection has indicated that there is a
sinusoidal missing in the present noise-floor band, or the inverse
filtering level for the present noise-floor band is equal or below
INVF\_LEVEL\_MID. If neither of these cases are true, the noise-floor
value is calculated according to:

![](media/image57.wmf){width="4.569444444444445in" height="0.94375in"}

The noise-floor values are smoothed by applying a LP filter over time
using previous noise floor values. Hence for every *nfBand*, the
smoothing is done according to:

![](media/image58.wmf){width="4.513888888888889in"
height="0.4305555555555556in"}

where **nf***~Prev~* are the **nf** values from the previous estimates
(where the most recent estimates is placed at the end of the vector,
i.e. position 2), and **h** is defined as:

![](media/image59.wmf){width="3.4166666666666665in" height="0.25in"}

### 5.6.4 Inverse filtering estimation

The inverse filtering detection is done on the frequency bands indicated
by **f***~TableNoise~* . For every band a tonality value is calculated
from the original input signal and the \"patched\" SBR signal. The
values are mapped to a specific regions given the \"Region borders\" in
the detectorParamsAAC struct, and the appropriate inverse filtering
value is given from the \"Region space\" also in detectorParamsAAC.

typedef enum

{

INVF\_OFF = 0,

INVF\_LOW\_LEVEL,

INVF\_MID\_LEVEL,

INVF\_HIGH\_LEVEL

}

INVF\_MODE;

static const DETECTOR\_PARAMETERS detectorParamsAAC = {

{ 1.0f, 10.0f, 14.0f, 19.0f}, /\* Region borders SBR. \*/

{ 0.0f, 3.0f, 7.0f, 10.0f}, /\* Region borders Orig. \*/

{25.0f, 30.0f, 35.0f, 40.0f}, /\* Region borders Nrg. \*/

4, /\* Number of borders SBR. \*/

4, /\* Number of borders orig. \*/

4, /\* Number of borders Nrg. \*/

1.0f, /\* Delta value for hysteresis. \*/

{ /\* Region space. \*/

{INVF\_MID\_LEVEL, INVF\_LOW\_LEVEL, INVF\_OFF, INVF\_OFF, INVF\_OFF},
/\* \| \*/

{INVF\_MID\_LEVEL, INVF\_LOW\_LEVEL, INVF\_OFF, INVF\_OFF, INVF\_OFF},
/\* \| \*/

{INVF\_HIGH\_LEVEL, INVF\_MID\_LEVEL, INVF\_LOW\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\*regionSbr\*/

{INVF\_HIGH\_LEVEL, INVF\_HIGH\_LEVEL,INVF\_MID\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\* \| \*/

{INVF\_HIGH\_LEVEL, INVF\_HIGH\_LEVEL,INVF\_MID\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\* \| \*/

},/\*\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-- regionOrig
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--\*/

{ /\* Region space transient. \*/

{INVF\_LOW\_LEVEL, INVF\_LOW\_LEVEL, INVF\_LOW\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\* \| \*/

{INVF\_LOW\_LEVEL, INVF\_LOW\_LEVEL, INVF\_LOW\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\* \| \*/

{INVF\_HIGH\_LEVEL,INVF\_MID\_LEVEL, INVF\_MID\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\*regionSbr\*/

{INVF\_HIGH\_LEVEL,INVF\_HIGH\_LEVEL, INVF\_MID\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\* \| \*/

{INVF\_HIGH\_LEVEL,INVF\_HIGH\_LEVEL, INVF\_MID\_LEVEL, INVF\_OFF,
INVF\_OFF}, /\* \| \*/

},/\*\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-- regionOrig
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--\*/

{-4, -3, -2, -1, 0} /\*Reduction factor of the inverse filtering for low
energies.\*/

};

static const float hysteresis = 1.0f; /\* Delta value for hysteresis.
\*/

The parameters *Tavg* and *TavgSbr* are calculated for every inverse
filtering band by averaging the tonality values in the **T** and
**Tsbr** matrices over the frequency regions indicated by
**f***~TableNoise~* according to (outlined for band *invBand*):

![](media/image60.wmf){width="3.3465277777777778in"
height="0.7361111111111112in"}

![](media/image61.wmf){width="3.5555555555555554in"
height="0.7361111111111112in"}

The values are subsequently filtered by a two tap FIR filter according
to:

![](media/image62.wmf){width="3.013888888888889in"
height="0.2222222222222222in"}

![](media/image63.wmf){width="3.611111111111111in"
height="0.2222222222222222in"}

where the ![](media/image64.wmf){width="0.5277777777777778in"
height="0.2222222222222222in"} and
![](media/image65.wmf){width="0.7222222222222222in"
height="0.2222222222222222in"}are the *Tavg* and *TavgSbr* from the
previous frame.

The *avgNrg* parameter is similarly calculated:

![](media/image66.wmf){width="1.75in" height="0.4305555555555556in"}

The region borders for the SBR tonality and the original tonality is
modified given previous values. The modification is done by adding the
\"hysteresis\" value to the upper border of the previous region, and
subtracting the hysteresis value from the lower border of the previous
region. This gives the region-borders used for the detection of the
present band in the present frame. The following pseudo-code outlines
how the hysteresis is applied, where the quantSteps are the region
border given in detectorParamsAAC.

if(prevRegion \< numRegions)

quantStepsTmp\[prevRegion\] = quantSteps\[prevRegion\] + hysteresis;

if(prevRegion \> 0)

quantStepsTmp\[prevRegion - 1\] = quantSteps\[prevRegion - 1\] -
hysteresis;

The region corresponding to the filtered tonality values for the
original and the SBR signal is obtained by finding the region that has
an upper border higher than the present value, and a lower border lower
or equal to the present value. This means that if the present value is
smaller than the first value in the border vector, the region returned
will be zero, and so on.

The regions for the original and the SBR signal are used to index the
region space as indicated by the detectorParamsAAC, and the inverse
filtering level value corresponding to the element pointed out by the
region indexes is returned. Different region spaces are used for frames
where a transient is detected.

Subsequently an energy compensation is applied. The energy-value
calculated from the auto correlation is mapped to a region defined in
detectorParamsAAC. The index value is subtracted from the inverse
filtering level obtained from the region space, and this gives the final
inverse filtering level stored in the *bs\_inv\_filt* vector.

### 5.6.5 Additional sines estimation

The additional sines estimation module, estimates for which frequency
bands a strong sinusoidal component will be missing after high frequency
reconstruction in the decoder. The result of the detection may not
include a detection of a new siusoidal component unless the frame
contains a transient, as defined by the transient detector, or unless
the previous frame contained a transient positioned less than nine QMF
slots from the trailing border of the previous frame. Such a detection
will be removed.

The detection algorithm firstly calculates the input data upon which
detection is done, based on the **T** and **Tsbr** values.

![](media/image67.wmf){width="5.513888888888889in"
height="0.5416666666666666in"}

![](media/image68.wmf){width="5.708333333333333in"
height="1.0965277777777778in"}

![](media/image69.wmf){width="6.180555555555555in"
height="1.0965277777777778in"}

The detection system is based on using guide-vectors holding information
on previous detections. There are two different guide-vectors:

**- guidevectorDiff** (has the frequency resolution of the
scalefactorbands)

**- guidevectorOrig** (has the frequency resolution of the QMF)

For every frame two tonality estimates in time are available, and hence
two estimates in time for the **diff**, **sfm**, **sfmsbr** parameters
are available as well. For every estimate a detection is done using the
guide-vectors from the previous detection. The results from the separate
detections are finally merged into one decision reflecting the current
frame

The detection algorithm is applied for every estimate, using
guide-vectors from the previous detection and producing a detection
vector and new guide-vectors. The algorithm is outlined below for
tonality estimate *l~0~*.

Firstly, for every scalefactor band the difference signal is compared to
a threshold *thresTemp.* The threshold is calculated based on the
guide-vectors and a decay-factor according to:

thresTemp = guideVectorDiff\[i\]\[l0\] ?

max(decayGuideDiff\*guideVectorDiff\[i\]\[l0\],thresHoldDiffGuide):\
thresHoldDiff;

thresTemp = min(thresTemp, thresHoldDiff);

If the difference **diff** for a scalefactor band is higher than the
threshold, the detection vector is set to one for this scalefactor band,
and the new guide vector is given the current difference value for the
present scalefactor band. If the difference in tonality is lower than
the threshold, but the guide vector indicated that present scale factor
band had a detected missing sine in for the previous tonality estimate,
the guide vector \"guideVectorOrig\", is assigned the thresHoldToneGuide
value, in order to track the decay of the original tone instead of the
difference signal. This is outlined for scalefactor band i, in the
following pseudo-code:

if(diff\[i\]\[l0\] \> thresTemp){

detVec\[i\]\[l0\] = 1;

guideVectorDiff\[i\]\[l0+1\] = diff\[i\]\[l0\];

}

else{

if(guideVectorDiff\[i\]){

guideVectorOrig\[i\]\[l0\] = thresHoldToneGuide;

}

}

A second detection is done for all scalefactor bands where
guideVectorOrig is not zero. The threshold used is calculated according
to:

thresOrig =
max(guideVectorOrig\[i\]\[l0\]\*decayGuideOrig,thresHoldToneGuide);

thresOrig = min(thresOrig,thresHoldTone);

If the tonality value in **T** for any QMF subband within the a
scalefactor band is above the threshold the detection vector element for
this subband is set to one, as well as the new guide vector. The
following pseudo-code outlines the second round of detection, for
scalefactor band *i*, where *ll* and *lu* are the lower and upper QMF
subband borders for the present scalefactor band:

if(guideVectorOrig\[i\]\[l0\]){

for(j= ll;j\<lu;j++){

if(T\[j\]\[l0\] \> thresOrig){

detVec\[i\]\[l0\] = 1;

guideVectorOrig\[i\]\[l0+1\] = T\[j\]\[l0\];

}

}

}

Finally, for every scalefactor band, a detection is done in order to
make sure that one single strong sinusoidal in the original signal is
not replaced (by patching) by several strong sinusoids in the SBR
signal. For all scalefactor bands larger than one QMF subband, the
values of **sfm** and **sfmSbr** is compared. This is done according to:

for(j= ll;j\<lu;j++){

if(T\[j\]\[l0\] \> thresOrig &&

(sfmSbr\[i\]\[l0\] \> sfmThresSbr && sfm\[i\]\[l0\]\<sfmThresOrig)){

detVec\[i\]\[l0\] = 1;

guideVectorOrig\[i\]\[l0+1\] = T\[j\]\[l0\];

}

}

However, for the scalefactor bands only containing one QMF subband the
above matrices are defined according to:

if(T\[ll\]\[l0\] \> thresHoldTone &&

(diff\[+1\]\[l0\] \< 1/thresHoldTone \|\|

diff\[i-1\]\[l0\] \< 1/thresHoldTone)){

detVec\[i\]\[l0\] = 1;

guideVectorOrig\[i\]\[l0+1\] = T\[ll\]\[l0\];

}

The above is applied for every estimate, i.e. twice per frame. If a new
detection is allowed, e.g. there is a transient present in the frame,
the following additional algorithmic step is performed:

\- Identify adjacent scalefactor bands where detection of a missing sine
is done in both bands

\- Find the QMF subband within each scalefactor band that has the
highest tonality

\- If the QMF subband with the highest tonality value are adjacent,
remove the detection for the scalefactor band with the lowest tonality.

Finally the detection decisions from the different detections are merged
together, according to:

for(i = 0; i\< nSfb; i++){

for(est = start; est \< totNoEst; est++){

bs\_add\_harmonic\[i\] = bs\_add\_harmonic\[i\] \|\| detVec\[i\]\[est\];

}

}

Here *start* equals two if the *newDetectionAllowed* flag is set,
otherwise it is set to zero.

If the *newDetectionAllowed* flag is not set, detections that were not
present before are removed, according to:

if(!newDetectionAllowed){

for(i=0;i\<nSfb;i++){

if(bs\_add\_harmonic\[i\] -- prev\_bs\_add\_harmonic\[i\] \> 0)

bs\_add\_harmonic\[i\] = 0;

}

}

Apart from detection in which scalefactor band a sinusoidal should be
added the module also calculates an energy compensation vector. This is
used in the envelope estimation module.

For every scalefactor band where a missing sine has been detected the
maximum tonality value in the T matrix is found, indicated by *maxPosF*
(indicating the subband) and *maxPosT* (indicating the QMF slot). If
*maxPosF* coincides with a scalefactor band border and a detection was
not done for the adjacent scalefactor band, a compensation value is
calculated according to (here outlined for the case where the *maxPosF*
value coincides for the lower scalefactorband border):

compValue = (int) (fabs(ILOG2\*log(diff\[i - 1\]\[maxPosT\] +EPS)) +
0.5f);

if (compValue \> maxComp)

compValue = maxComp;

if(!pAddHarmonicsScaleFactorBands\[i-1\]) {

if(tonality\[maxPosF -1\]\[maxPosT\] \>
tonalityQuota\*tonality\[maxPosF\]\[maxPosT\]){

compVec\[i-1\] = -1\*compValue;

}

}

Finally the detection algorithm compensates for the case where a strong
sinusoidal is present in the patched SBR signal where there were no
strong sinusoidal in the original, and at the same time there is a
sinusoidal missing in the adjacent scalefactor band. This is done for
all scalefactor bands where a sine is missing (except for the first and
the last scalefactor band), according to the following:

compValue = (int) (fabs(ILOG2\*log(diff\[i - 1\]\[maxPosT\]+EPS)) +
0.5f);

if (compValue \> maxComp)

compValue = maxComp;

if(1/diff\[i-1\]\[maxPosT\] \> diffQuota\*diff\[i\]\[maxPosT\]){

compVec\[i-1\] = -1\*compValue;

}

compValue = (int) (fabs(ILOG2\*log(diff\[i + 1\]\[maxPosT\]+EPS)) +
0.5f);

if (compValue \> maxComp)

compValue = maxComp;

if(1/diff\[i+1\]\[maxPosT\] \> diffQuota\*diff\[i\]\[maxPosT\]){

compVec\[i+1\] = compValue;

}

The bitstream element *bs\_add\_harmonic\_flag* is set to one if any
element of the *bs\_add\_harmonic* is not zero, otherwise it is set to
zero.

5.7 Data quantization
---------------------

The spectral envelope scalefactors are quantized in 3dB steps or in
1.5dB steps, dependent on the time frequency resolution of the current
SBR frame, and *bs\_amp\_res*. For the case where there is only one SBR
envelope per SBR frame and of SBR frame class FIXFIX, 1.5 dB steps are
always used, disregarded the value of *bs\_amp\_res*.

For mono and stereo without channel coupling the quantization is done
according to:

![](media/image70.wmf){width="5.791666666666667in"
height="0.5416666666666666in"}

where ![](media/image71.wmf){width="1.5965277777777778in"
height="0.4722222222222222in"} and
![](media/image72.wmf){width="3.5277777777777777in" height="0.5in"}

For the coupled channel mode, the left channel is quantized according to
the above, while the right channel should be quantized according to:

![](media/image73.wmf){width="4.236111111111111in"
height="0.3055555555555556in"}

The noise floor scalefactors data is always quantized in 3dB steps. For
stereo without channel coupling and for mono the channels are quantized
according to:

![](media/image74.wmf){width="4.138888888888889in"
height="0.3055555555555556in"},

where ![](media/image75.wmf){width="0.5694444444444444in"
height="0.2638888888888889in"} shall be limited to the interval
![](media/image76.wmf){width="0.4305555555555556in" height="0.25in"}.

For coupling however, the right and left channels are quantized
according to:

![](media/image77.wmf){width="3.75in" height="0.5555555555555556in"},

![](media/image78.wmf){width="5.361111111111111in"
height="0.5277777777777778in"}

where

![](media/image79.wmf){width="0.7638888888888888in"
height="0.2638888888888889in"} shall be limited to the interval
![](media/image80.wmf){width="1.3055555555555556in"
height="0.2777777777777778in"} and
![](media/image81.wmf){width="0.7083333333333334in"
height="0.2638888888888889in"} is limited to the interval
![](media/image82.wmf){width="0.4305555555555556in" height="0.25in"}.

In the case of coupling, the
![](media/image83.wmf){width="0.7638888888888888in"
height="0.2638888888888889in"}and![](media/image84.wmf){width="0.75in"
height="0.2638888888888889in"} values shall be quantized to multiples of
two, e.g. ![](media/image85.wmf){width="0.8333333333333334in"
height="0.25in"}.

5.8 Envelope and noise floor coding
-----------------------------------

The spectral envelope scalefactors and noise floor scalefactors are
delta coded in either the time direction or the frequency direction,
according to the preferred choice indicated in **bs\_df\_env**(*l*) and
**bs\_df\_noise**(*l*). The **bs\_df\_env** and **bs\_df\_noise**
elements are chosen so that the total number of bits required for coding
the scalefactor data of the present frame is minimised, with the
reservation for the case when *reset* = 1. In this case delta coding in
the time direction is not allowed for the first SBR envelope or noise
floor of that SBR frame.

The above minimization of envelope bits are for stereo done in both
coupling and left/right stereo mode and based on this the stereo mode is
chosen so that the total number of bits required is minimized.

Below the delta coding of envelope scalefactors and noise floor
scalefactors are defined.

![](media/image86.wmf){width="5.569444444444445in"
height="6.388888888888889in"}

where ![](media/image87.wmf){width="2.5833333333333335in"
height="0.4722222222222222in"} and,

where ![](media/image88.wmf){width="0.5416666666666666in"
height="0.25in"} and ![](media/image89.wmf){width="0.3333333333333333in"
height="0.25in"} is defined below. As
![](media/image90.wmf){width="0.2222222222222222in" height="0.25in"}
represents the envelope scalefactors for the current SBR frame, the
envelope scalefactors from the previous SBR frame is denoted
![](media/image91.wmf){width="0.2222222222222222in" height="0.25in"}.
Envelope scalefactors from the previous SBR frame,
![](media/image92.wmf){width="0.2222222222222222in" height="0.25in"} is
needed when delta coding in time direction over SBR frame boundaries.
The number of SBR envelopes of the previous SBR frame is denoted
![](media/image93.wmf){width="0.19375in" height="0.2222222222222222in"},
and is also needed in that case, as well as frequency resolution vector
of the previous SBR frame, denoted **r\'**.

![](media/image94.wmf){width="2.763888888888889in"
height="1.0833333333333333in"}and
![](media/image95.wmf){width="1.8888888888888888in" height="0.5in"}.

The delta coding of the noise floor scalefactors are defined as:

![](media/image96.wmf){width="4.152777777777778in" height="3.25in"}

where

![](media/image97.wmf){width="2.5833333333333335in"
height="0.4722222222222222in"}

and where ![](media/image98.wmf){width="0.20833333333333334in"
height="0.20833333333333334in"} is the noise floor scalefactors from the
previous SBR frame
and![](media/image99.wmf){width="0.20833333333333334in"
height="0.25in"}is the number of noise floors from the previous SBR
frame. ![](media/image100.wmf){width="0.7083333333333334in"
height="0.25in"} and ![](media/image101.wmf){width="0.69375in"
height="0.25in"} are stored as bitstream element as shown below prior to
Huffman coding.

![](media/image102.wmf){width="3.2777777777777777in" height="0.5in"}

![](media/image103.wmf){width="3.4166666666666665in" height="0.5in"}

For the envelope scalefactors and the noise floor scalefactors different
Huffman tables are used dependent on coding directions, quantization and
stereo mode, according to in \[1\], sub clause 4.A.6.1 Table 4.A.76

6 Bitstream
===========

Figure 10 below gives a brief hierarchical representation of the SBR and
parametric stereo parts of the aacPlus bitstream, with references to the
corresponding decoder specifications.  An overview of
sbr\_extension\_data() is given in \[1\], Figure 4.19A, and subclause
4.4.2.8 of \[1\] defines the syntax.  Clearly, the operation of the SBR
Bitstream Multiplexer in Figure 5 is defined by this syntax.  The
optional CRC calculation is also defined by the decoder description
\[1\], subclause 4.5.2.8.1.  For convenience, pointers to the relevant
sections in the present document are given within paranthesises in
Figure 10.

extension\_payload()                 \[1\], Amendment Subpart 4, Table
4.51\
  sbr\_extension\_data()              \[1\], Subclause 4.4.2.8, Table
4.54A\
    sbr\_header()                     \", \", Table 4.55A (5.3)\
    sbr\_data()                       \", \", Table 4.56A\
      sbr\_single\_channel\_element()   \", \", Table 4.57A\
        sbr\_grid()                   \", \", Table 4.61A (5.4.3)\
        sbr\_dtdf()                   \", \", Table 4.62A (5.8)\
        sbr\_invf()                   \", \", Table 4.63A (5.6.4)\
        sbr\_envelope()               \", \", Table 4.64A (5.5, 5.7,
5.8)\
        sbr\_noise()                  \", \", Table 4.65A (5.6.3, 5.7,
5.8)\
        sbr\_sinusoidal\_coding()      \", \", Table 4.66A (5.6.5)\
        sbr\_extension()             \[7\], Subclause 8.A.2, Table
8.A.1\
          ps\_data()                 \[7\], Subclause 8.4.1, Table 8.1

Figure 10: Enhanced aacPlus with parametric stereo bitstream hierarchy

######## Annex A (informative): Change history

  -------------------- -------------- -------------- -------- --------- ------------------------ --------- ---------
  **Change history**                                                                                       
  **Date**             **TSG SA\#**   **TSG Doc.**   **CR**   **Rev**   **Subject/Comment**      **Old**   **New**
  2004-09              25             SP-040636                         Approved at SA\#25       2.0.0     6.0.0
  2007-09              36                                               Version for Release 7    6.0.0     7.0.0
  2008-12              42                                               Version for Release 8    7.0.0     8.0.0
  2009-12              46                                               Version for Release 9    8.0.0     9.0.0
  2011-03              51                                               Version for Release 10   9.0.0     10.0.0
  2012-09              57                                               Version for Release 11   10.0.0    11.0.0
  2014-09              65                                               Version for Release 12   11.0.0    12.0.0
  2015-12              70                                               Version for Release 13   12.0.0    13.0.0
  -------------------- -------------- -------------- -------- --------- ------------------------ --------- ---------

  -------------------- ------------- ---------- -------- --------- --------- -------------------------------- -----------------
  **Change history**                                                                                          
  **Date**             **Meeting**   **TDoc**   **CR**   **Rev**   **Cat**   **Subject/Comment**              **New version**
  2017-03              75                                                    Version for Release 14           14.0.0
  2018-06              80                                                    Version for Release 15           15.0.0
  2020-07              \-            \-         \-       \-        \-        Update to Rel-16 version (MCC)   **16.0.0**
  -------------------- ------------- ---------- -------- --------- --------- -------------------------------- -----------------
