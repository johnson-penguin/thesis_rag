![](media/image1.jpeg){width="7.0875in" height="3.4229166666666666in"}

> Keywords
>
> 3GPP, MBMS, IoT

  {#section .TT}

Contents {#contents .TT}
========

[5](#foreword)

[6](#scope)

[6](#references)

[7](#definitions-symbols-and-abbreviations)

[7](#definitions)

[7](#abbreviations)

[8](#use-cases)

[8](#general)

[8](#use-case-1---periodic-andor-planned-data-delivery)

[8](#description)

[8](#recommended-requirements)

[8](#use-case-2-initially-unplanned-data-delivery)

[8](#description-1)

[9](#recommended-requirements-1)

[9](#use-case-3-initially-unplanned-data-delivery-for-critical-data)

[9](#description-2)

[9](#recommended-requirements-2)

[9](#iot-device-analysis)

[9](#general-1)

[9](#classes-of-constrained-devices)

[10](#gpp-device-categories)

[10](#device-classification-for-mbms-iot-reception)

[11](#mbms-for-nb-iot-device-categories)

[11](#mbms-user-service-announcement-profile)

[11](#mbms-iot-profiles-for-file-download-delivery-method)

[11](#introduction)

[12](#common-fdt-instance-and-file-attributes-for-mbms-iot-profiles)

[12](#fdt-instance-specific-elements-and-attributes-for-mbms-iot-profiles)

[12](#fdt-file-specific-elements-and-attributes-for-mbms-iot-profiles)

[13](#gpp-defined-fdt-extensions-for-mbms-iot-profiles)

[14](#solutions)

[14](#overview-of-coap)

[14](#general-2)

[15](#comparison-to-http)

[15](#logical-architecture-model)

[15](#general-3)

[15](#coap-messaging-model)

[16](#methods-and-response-codes)

[17](#message-format)

[18](#options)

[19](#caching)

[19](#proxying)

[19](#security-and-dtls)

[19](#block-wise-transfers)

[19](#general-4)

[20](#structure-of-a-block-option)

[21](#overview-of-lwm2m)

[23](#solutions-for-file-repair-using-coap)

[23](#general-5)

[24](#byte-range-request-based-file-repair)

[24](#general-6)

[24](#option-1-use-uri-query-option-in-coap)

[25](#option-2-define-a-new-coap-option-range)

[27](#block-request-based-file-repair)

[27](#general-7)

[27](#option-3-block-request-for-repair-data-after-broadcast-transmission-of-source-and-repair-symbols)

[29](#option-4-block-request-for-repair-data-after-broadcast-transmission-of-only-repair-symbols)

[30](#comparison-of-block-request-based-file-repair-options)

[30](#solution-evaluation)

[31](#binary-data-formats)

[31](#general-8)

[31](#efficient-extensible-interchange-or-efficient-xml-exchange-exi)

[32](#well-known-binary-formats)

[33](#ad-hoc-binary-format)

[36](#key-length-value-klv-format)

[36](#performance-comparison-of-binary-data-formats)

[36](#general-considerations)

[37](#performance-comparison)

[40](#summary)

[40](#recommendation)

[40](#solution-for-announcement-during-wake-up-periods)

[41](#solution-for-announcement-with-critical-data-delivery)

[42](#solution-for-reception-report-procedures)

[44](#solution-for-service-announcement-procedures)

[44](#unicast-delivery-of-service-announcement-using-coap)

[44](#service-announcement-profiles-for-iot-devices)

[53](#asn.1-per-binary-fdt-instance-definition)

[54](#conclusions)

[56](#annex-a-change-history)Foreword 1 Scope 2 References 3
Definitions, symbols and abbreviations 3.1 Definitions 3.2 Abbreviations
4 Use cases 4.0 General 4.1 Use case 1 - Periodic and/or planned data
delivery 4.1.1 Description 4.1.2 Recommended Requirements 4.2 Use case 2
-- Initially Unplanned data delivery 4.2.1 Description 4.2.2 Recommended
requirements 4.3 Use case 3 -- Initially Unplanned data delivery for
critical data 4.3.1 Description 4.3.2 Recommended requirements 5 IoT
device analysis 5.0 General 5.1 Classes of constrained devices 5.2 3GPP
device categories 5.3 Device classification for MBMS IoT reception 6
MBMS for NB-IoT device categories 6.1 MBMS User Service Announcement
Profile 6.2 MBMS IoT profiles for file download delivery method 6.2.0
Introduction 6.2.1 Common FDT-Instance and File attributes for MBMS IoT
profiles 6.2.2 FDT-Instance specific Elements and Attributes for MBMS
IoT profiles 6.2.3 FDT File specific Elements and Attributes for MBMS
IoT profiles 6.2.4 3GPP-defined FDT extensions for MBMS IoT profiles 7
Solutions 7.1 Overview of CoAP 7.1.0 General 7.1.1 Comparison to HTTP
7.1.2 Logical Architecture Model 7.1.2.0 General 7.1.2.1 CoAP Messaging
Model 7.1.2.2 Methods and Response Codes 7.1.3 Message Format 7.1.4
Options 7.1.5 Caching 7.1.6 Proxying 7.1.7 Security and DTLS 7.1.8
Block-wise transfers 7.1.8.0 General 7.1.8.1 Structure of a Block Option
7.2 Overview of LwM2M 7.3 Solutions for File Repair using CoAP 7.3.0
General 7.3.1 Byte-Range Request based File Repair 7.3.1.0 General
7.3.1.1 Option 1: use Uri-Query option in CoAP 7.3.1.2 Option 2: define
a new CoAP option Range 7.3.2 Block Request based File Repair 7.3.2.0
General 7.3.2.1 Option 3: Block request for repair data after broadcast
transmission of source and repair symbols 7.3.2.2 Option 4: Block
request for repair data after broadcast transmission of only repair
symbols 7.3.2.3 Comparison of Block Request based File Repair Options
7.3.3 Solution evaluation 7.4 Binary data formats 7.4.0 General 7.4.1
Efficient Extensible Interchange or Efficient XML Exchange (EXI) 7.4.2
Well-known binary formats 7.4.3 Ad-hoc binary format 7.4.4
Key-Length-Value (KLV) format 7.4.5 Performance comparison of binary
data formats 7.4.5.1 General considerations 7.4.5.2 Performance
comparison 7.4.5.3 Summary 7.4.5.4 Recommendation 7.5 Solution for
announcement during wake-up periods 7.6 Solution for announcement with
critical data delivery 7.7 Solution for reception report procedures 7.8
Solution for service announcement procedures 7.8.1 Unicast delivery of
service announcement using CoAP 7.8.2 Service announcement profiles for
IoT devices 7.9 ASN.1 PER binary FDT instance definition 8 Conclusions
Annex A: Change history

Foreword
========

This Technical Report has been produced by the 3rd Generation
Partnership Project (3GPP).

The contents of the present document are subject to continuing work
within the TSG and may change following formal TSG approval. Should the
TSG modify the contents of the present document, it will be re-released
by the TSG with an identifying change of release date and an increase in
version number as follows:

Version x.y.z

where:

x the first digit:

1 presented to TSG for information;

2 presented to TSG for approval;

3 or greater indicates TSG approved document under change control.

y the second digit is incremented for all changes of substance, i.e.
technical enhancements, corrections, updates, etc.

z the third digit is incremented when editorial only changes have been
incorporated in the document.

1 Scope
=======

The present document studies and evaluates the enhancements at the
service layer to support massive file delivery for IoT devices. Devices
and network entities operating in the typically constrained environment
associated with IoT communications (e.g., processing power, storage,
battery life, bandwidth) might support the simplified mechanisms and
protocols for MBMS and associated unicast procedures as described in the
present document, as opposed to the regular MBMS operations as defined
in 3GPP TS 26.346. An IoT device described in the present document could
be for instance a NB-IoT device or an eMTC device.

The study considers the enhancements/simplifications in the following
areas:

\- Define the requirements and constraints for different IoT device
categories.

\- Review the existing multicast/broadcast service architecture in
support of MBMS delivery to IoT devices.

2 References
============

The following documents contain provisions which, through reference in
this text, constitute provisions of the present document.

\- References are either specific (identified by date of publication,
edition number, version number, etc.) or non‑specific.

\- For a specific reference, subsequent revisions do not apply.

\- For a non-specific reference, the latest version applies. In the case
of a reference to a 3GPP document (including a GSM document), a
non-specific reference implicitly refers to the latest version of that
document *in the same Release as the present document*.

\[1\] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".

\[2\] 3GPP TS 26.346: \"Multimedia Broadcast/Multicast Service (MBMS);
Protocols and codecs\".

\[3\] IETF RFC 3926 (October 2004): \"FLUTE - File Delivery over
Unidirectional Transport\", T. Paila, M. Luby, R. Lehtonen, V. Roca, R.
Walsh

\[4\] 3GPP TS 36.101: \"User Equipment (UE) radio transmission and
reception\".

\[5\] 3GPP TS 36.306: \"User Equipment (UE) radio access capabilities\".

\[6\] 3GPP TR 22.861: \"FS\_SMARTER - massive Internet of Things\".

\[7\] IETF RFC 7252 (June 2014): \"The Constrained Application Protocol
(CoAP)\", Z. Shelby, K. Hartke, C. Bormann.

\[8\] IETF RFC 6347 (January 2012): \"Datagram Transport Layer Security
Version 1.2\", E. Rescorla, N. Modadugu.

\[9\] OMA-TS-LightweightM2M-V1\_0-20170208-A: \"Lightweight Machine to
Machine Technical Specification\".

**\[10\] IETF RFC 7228 (May 2014): \"Terminology for Constrained-Node
Networks\", C. Bormann, M. Ersue, A. Keranen.**

**\[11\]** 3GPP TR 45.820: \"Cellular system support for ultra-low
complexity and low throughput Internet of Things (CIoT)\"

\[12\] IETF RFC 4919 (August 2007): \"IPv6 over Low-Power Wireless
Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem
Statement, and Goals\", N. Kushalnagar, G. Montenegro, C. Schumacher.

\[13\] IETF RFC 7959 (August 2006): \"Block-Wise Transfers in the
Constrained Application Protocol (CoAP)\", C. Bormann, Z. Shelby.

\[14\] <https://www.w3.org/XML/EXI/>

\[15\] <http://www.xfront.com/EXI/EXI.zip>

\[16\] <https://www.itu.int/en/ITU-T/asn1/Pages/asn1_project.aspx>

\[17\] <https://thrift.apache.org/>

\[18\] <https://github.com/google/protobuf>

\[19\]
<http://www.oss.com/asn1/resources/asn1-made-simple/encoding-rules.html>

\[20\] N. Gligorić, I. Dejanović and S. Krčo, \"Performance evaluation
of compact binary XML representation for constrained devices,\" 2011
International Conference on Distributed Computing in Sensor Systems and
Workshops (DCOSS), Barcelona, 2011, pp. 1-5.

\[21\] 3GPP TS 36.331: \"Evolved Universal Terrestrial Radio Access
(E-UTRA); Radio Resource Control (RRC); Protocol specification\".

\[22\] <https://www.w3.org/TR/2009/WD-exi-evaluation-20090407/>

\[23\]
<https://www.w3.org/WoT/IG/wiki/images/4/44/2016-04_EXI_for_WoT-1.pdf>

\[24\] Sebastian Bittl, Arturo A. Gonzalez, Michael Spahn, and Wolf A.
Heidrich, \"Performance Comparison of Data Serialization Schemes for
ETSI ITS Car-to-X Communication Systems\", International Journal on
Advances in Telecommunications, vol 8 no 1 & 2, 2015.

3 Definitions, symbols and abbreviations
========================================

3.1 Definitions
---------------

For the purposes of the present document, the terms and definitions
given in 3GPP TR 21.905 \[1\] and the following apply. A term defined in
the present document takes precedence over the definition of the same
term, if any, in 3GPP TR 21.905 \[1\].

3.2 Abbreviations
-----------------

For the purposes of the present document, the abbreviations given in
3GPP TR 21.905 \[1\] and the following apply. An abbreviation defined in
the present document takes precedence over the definition of the same
abbreviation, if any, in 3GPP TR 21.905 \[1\].

> ADPD Associated Delivery Procedure Description
>
> CoAP Constrained Application Protocol
>
> DASH Dynamic Adaptive Streaming over HTTP

eMBMS Evolved Multimedia Broadcast Multicast Services

eMTC enhanced Machine Type Communication

FLUTE File deLivery over Unidirectional Transport

IoT Internet of Things

> MPD Media Presentation Description

NB-IoT NarrowBand IoT

RTOS Real-Time Operating System

> RTP Real-Time Transport Protocol
>
> USBD User Service Bundle Description
>
> USD User Service Description
>
> UTC Universal Time Coordinated

XML Extensible Markup Language

4 Use cases
===========

4.0 General
-----------

3GPP TR 22.861 \[6\] identifies the use case families, traffic scenarios
and potential requirements for massive IoT. However, the use case
families in 3GPP TR 22.861 do not address the data delivery from the
network to a large amount of UEs. The following use cases present the
data delivery using MBMS User Services with additional requirements
compared to 3GPP TR 22.861.

4.1 Use case 1 - Periodic and/or planned data delivery
------------------------------------------------------

### 4.1.1 Description

This use case represents a periodic and/or planned file delivery to a
large number of devices. Smart water-metering devices are installed in
deep indoor and wake up once or twice a day to send the consumption
reports to the water-metering network that is regularly extended. The
payload size for uplink transmission is in the range of 12 to 100 bytes.
Based on growing amount of data, the system configuration is adjusted,
requiring the delivery of small configuration updates to all metering
devices. Moreover, the water-metering manufacturer regularly provides
non-critical software updates for bug fixes, performance improvements,
or new features/functionalities. For example, the clause E.2.4 of 3GPP
TR 45.820 \[11\] estimates a periodic inter-arrival time of 180 days
between software update events. This frequency is equivalent to twice
per year. Depending on the application, the update frequency can be
lower or higher. These devices require a battery lifetime of approximate
15 years and are significantly resource-constrained (processing and
storage).

### 4.1.2 Recommended Requirements

The following recommended requirements are considered:

\- The 3GPP system supports the reliable delivery and associated
procedures to ensure data integrity.

\- The 3GPP system supports the report on successful delivery.

\- The 3GPP system supports eMBMS delivery mechanisms and procedures for
devices with very limited capabilities (e.g. limited battery life of 15
years, limited processing and limited storage).

\- The 3GPP system supports a mechanism to inform the scheduled delivery
session to the devices that enables the UE to download the file at the
planned schedule time.- The 3GPP system supports a mechanism to
acknowledge a successful reception and action required (e.g. successful
file update).

In addition, the following recommended requirements are not directly
related to 3GPP system but necessary for IoT software update:

\- The update needs to be robust. An update does not make the device
unusable.

\- The update needs to be atomic. An update needs to be completely
installed or not at all.

\- The update needs to be fail-safe. There is a fall-back mode if the
update has failed.

4.2 Use case 2 -- Initially Unplanned data delivery
---------------------------------------------------

### 4.2.1 Description

This use case represents the unplanned data delivery to a large number
of devices. A device manufacturer wants to distribute a
software/firmware update after some bug fixes. These devices may wake up
periodically (e.g., every 12 hours to upload measurement data), or
dynamically, for instance, when the buffer which contains measurement
data is about to be full. The information that a new software/firmware
update is available is transmitted during these wake-up periods. The
device recommended requirements and constraints are similar to the use
case 1.

### 4.2.2 Recommended requirements

In addition to the recommended requirements in clause 4.1.2, the
following additional recommended requirement is considered:

\- The 3GPP system supports a mechanism to inform the UE during its
wake-up periods about any newly scheduled download delivery sessions.

4.3 Use case 3 -- Initially Unplanned data delivery for critical data
---------------------------------------------------------------------

### 4.3.1 Description

This use case represents the unplanned critical data delivery to a large
number of devices. A bug in software could be a target for exploitation
or is being exploited by unwanted people to perform a massive attack if
the devices are connected to the Internet. To solve the issue, a device
manufacturer wants to distribute as soon as possible a critical
software/firmware update. The device recommended requirements and
constraints are similar to the use case 1. But in contrast to use case
2, the device manufacturer wants to speed up the update mechanism such
that devices can obtain information on a newly scheduled download
delivery session, as opposed to having to wait until the next wake-up
period to obtain such information.

### 4.3.2 Recommended requirements

In addition to the recommended requirements in clause 4.1.2, the
following additional recommended requirement is considered:

\- The 3GPP system supports a mechanism to page the UE in order to
inform the UE about a newly schedule download delivery session.

5 IoT device analysis
=====================

5.0 General
-----------

In IoT devices, there are two separate parts: connectivity and
application. The connectivity part is responsible for the connectivity
between the IoT device and the network (e.g. LTE modem) while the
application part is used for a specific application/use case. Each part
may have its own software/firmware/OS. The clause 5.1 specifies the
classes of devices at the application, the clause 5.2 presents the
device categories for LTE connectivity.

5.1 Classes of constrained devices
----------------------------------

RFC 7228 \[10\] defines constrained devices as small devices with
limited CPU, memory, and power resources. The devices are often used as
sensors/actuators, smart objects, or smart devices. RFC 7228 \[10\]
identifies 3 classes of constrained devices as in table 5.1-1 to provide
rough indications of device capabilities.

Table 5.1-1: Classes of constrained devices (KiB = 1024 bytes) \[12\]

  ------------- ---------------------- ------------------------
  Name          Data size (e.g. RAM)   Code size (e.g. Flash)
  Class 0, C0   \<\< 10 KiB            \<\< 100 KiB
  Class 1, C1   \~ 10 KiB              \~ 100 KiB
  Class 2, C2   \~ 50 KiB              \~ 250 KiB
  ------------- ---------------------- ------------------------

NOTE: RFC 7228 uses the term KiB and this term is only applied in the
clause 5.1 of the present document.

The description of each class is extracted from RFC 7228 \[10\] as
follows:

*\"Class 0 devices are very constrained sensor-like motes. They are so
severely constrained in memory and processing capabilities that most
likely they will not have the resources required to communicate directly
with the Internet in a secure manner (rare heroic, narrowly targeted
implementation efforts notwithstanding). Class 0 devices will
participate in Internet communications with the help of larger devices
acting as proxies, gateways, or servers. Class 0 devices generally
cannot be secured or managed comprehensively in the traditional sense.
They will most likely be preconfigured (and will be reconfigured rarely,
if at all) with a very small data set. For management purposes, they
could answer keepalive signals and send on/off or basic health
indications.*

*Class 1 devices are quite constrained in code space and processing
capabilities, such that they cannot easily talk to other Internet nodes
employing a full protocol stack such as using HTTP, Transport Layer
Security (TLS), and related security protocols and XML-based data
representations. However, they are capable enough to use a protocol
stack specifically designed for constrained nodes (such as the
Constrained Application Protocol (CoAP) over UDP) and participate in
meaningful conversations without the help of a gateway node. In
particular, they can provide support for the security functions required
on a large network. Therefore, they can be integrated as fully developed
peers into an IP network, but they need to be parsimonious with state
memory, code space, and often power expenditure for protocol and
application usage.*

*Class 2 devices are less constrained and fundamentally capable of
supporting most of the same protocol stacks as used on notebooks or
servers. However, even these devices can benefit from lightweight and
energy-efficient protocols and from consuming less bandwidth.
Furthermore, using fewer resources for networking leaves more resources
available to applications. Thus, using the protocol stacks defined for
more constrained devices on Class 2 devices might reduce development
costs and increase the interoperability.*

*Constrained devices with capabilities significantly beyond Class 2
devices exist. They are less demanding from a standards development
point of view as they can largely use existing protocols unchanged. The
present document therefore does not make any attempt to define classes
beyond Class 2. These devices can still be constrained by a limited
energy supply.\"*

5.2 3GPP device categories
--------------------------

3GPP TS 36.306 \[5\] defines categories for NB-IoT and MTC devices:
Cat-NB1, Cat-NB2, Category M1, Category M2. 3GPP TS 36.306 clauses 4.1A
and 4.1C specify uplink and downlink capability for MTC and NB-IoT
categories, respectively. However, 3GPP TS 36.306 does not specify
whether NB-IoT or MTC devices support certain MBMS operations and
capabilities (e.g. XML parsing and processing).

5.3 Device classification for MBMS IoT reception
------------------------------------------------

The classification in clause 5.1 is applied for the application part
while the 3GPP device categories is applied for the connectivity part.
Depending on the application, use case, and device capabilities,
multiple combinations from the classification in clause 5.1 and the 3GPP
device categories are possible. For example, a smart water-metering
device may use Cat-NB1 for the connectivity and Class 1 for the
application with finite battery power. The MBMS client is between the
applications and the connectivity functions. Classification and
dimensioning provided by RFC 7228 \[10\] and by 3GPP TS 36.306 \[5\]
cannot be applied directly to the MBMS client. Consequently, 2
classification categories are here proposed for the MBMS reception point
of view: low-end and high-end; depending on the application and/or use
case.

The low-end IoT category represents the devices with limited
capabilities such as processing, memory, battery etc. The MBMS User
Services for this category have to be simplified as much as possible to
address a wide range of devices, applications, and use cases. For
example, Class 1 devices do not recommend full XML processing \[12\].

The high-end IoT category represents the devices with moderate or good
capabilities (e.g., smart endpoints, IoT gateways). This device category
may have additional capabilities (e.g. XML parsing/processing) compared
to the low-end IoT category.

The low-end IoT category may support reduced MBMS processing (e.g. no
XML). The high-end IoT category may support an MBMS profile without
requirements for multimedia services (e.g. neither RTP nor DASH).

6 MBMS for NB-IoT device categories
===================================

6.1 MBMS User Service Announcement Profile
------------------------------------------

3GPP TS 26.346 \[2\] defines different procedures, mechanisms and
protocols for MBMS User Services. The table 6.1-1 shows the profiling
for each IoT category:

Table 6.1-1: List of supported procedures and methods for low-end and
high-end IoT categories

+----------------+----------------+----------------+----------------+
|                |                | Recommended    | Recommended    |
|                |                | for Low-end    | for High-end   |
|                |                | IoT category   | IoT category   |
|                |                | Profile        | Profile        |
+----------------+----------------+----------------+----------------+
| Service        | MBMS bearer    | Yes (Note 1)   | Yes            |
| Announcement   |                |                |                |
+----------------+----------------+----------------+----------------+
|                | Interactive    | No             | Yes            |
|                | Announcement   |                |                |
|                | Function       |                |                |
+----------------+----------------+----------------+----------------+
|                | Point-to-Point | Yes            | Yes            |
|                | push bearer    |                |                |
+----------------+----------------+----------------+----------------+
| Associated     | File Repair -- | Yes (Note 3)   | Yes            |
| delivery       | Byte Range     |                |                |
| procedure      | based          |                |                |
+----------------+----------------+----------------+----------------+
|                | File Repair -- | No             | No             |
|                | Symbol based   |                |                |
+----------------+----------------+----------------+----------------+
|                | Reception      | Yes (Note 3)   | Yes            |
|                | Report         |                |                |
+----------------+----------------+----------------+----------------+
|                | Consumption    | No             | No             |
|                | Report         |                |                |
+----------------+----------------+----------------+----------------+
| Delivery       | Download       | Yes            | Yes            |
| method         |                |                |                |
+----------------+----------------+----------------+----------------+
|                | Streaming      | No             | No             |
+----------------+----------------+----------------+----------------+
|                | Group          | No             | No             |
|                | communication  |                |                |
+----------------+----------------+----------------+----------------+
|                | Transparent    | No             | No             |
+----------------+----------------+----------------+----------------+
| NOTE 1: In     |                |                |                |
| clause 5.2.3.1 |                |                |                |
| of 3GPP TS     |                |                |                |
| 26.346, the    |                |                |                |
| possibility to |                |                |                |
| download       |                |                |                |
| session        |                |                |                |
| parameters     |                |                |                |
| from an HTTP   |                |                |                |
| server         |                |                |                |
| resolved from  |                |                |                |
| the Service    |                |                |                |
| Announcement   |                |                |                |
| may not be     |                |                |                |
| applicable for |                |                |                |
| low-end IoT    |                |                |                |
| category. A    |                |                |                |
| CoAP based     |                |                |                |
| solution       |                |                |                |
| instead of     |                |                |                |
| HTTP may be    |                |                |                |
| more           |                |                |                |
| efficient.     |                |                |                |
|                |                |                |                |
| NOTE 2: In     |                |                |                |
| clause 5.2.4   |                |                |                |
| of 3GPP TS     |                |                |                |
| 26.346, the    |                |                |                |
| HTTP URL used  |                |                |                |
| by the UE to   |                |                |                |
| obtain USD via |                |                |                |
| unicast may    |                |                |                |
| not be         |                |                |                |
| applicable to  |                |                |                |
| low-end IoT    |                |                |                |
| category. A    |                |                |                |
| CoAP based     |                |                |                |
| solution for   |                |                |                |
| Interactive    |                |                |                |
| Announcement   |                |                |                |
| Function       |                |                |                |
| instead of     |                |                |                |
| HTTP may be    |                |                |                |
| more           |                |                |                |
| appropriate.   |                |                |                |
|                |                |                |                |
| NOTE 3: File   |                |                |                |
| repair and     |                |                |                |
| reception      |                |                |                |
| report         |                |                |                |
| messages using |                |                |                |
| HTTP protocol  |                |                |                |
| in a single    |                |                |                |
| TCP connection |                |                |                |
| (3GPP TS       |                |                |                |
| 26.346 clauses |                |                |                |
| 9.3 and 9.4)   |                |                |                |
| is not         |                |                |                |
| desirable in   |                |                |                |
| the low-end    |                |                |                |
| IoT category.  |                |                |                |
| Simplified     |                |                |                |
| file repair    |                |                |                |
| and reception  |                |                |                |
| report         |                |                |                |
| procedures are |                |                |                |
| preferable -   |                |                |                |
| (e.g. file     |                |                |                |
| repair and     |                |                |                |
| reception      |                |                |                |
| report based   |                |                |                |
| on CoAP,       |                |                |                |
| according to   |                |                |                |
| the methods    |                |                |                |
| described in   |                |                |                |
| clauses 7.3.1  |                |                |                |
| and 7.3.2 in   |                |                |                |
| the present    |                |                |                |
| document).     |                |                |                |
|                |                |                |                |
| NOTE 4: The    |                |                |                |
| point-to-point |                |                |                |
| push bearer in |                |                |                |
| the present    |                |                |                |
| document       |                |                |                |
| indicates the  |                |                |                |
| unicast        |                |                |                |
| delivery of    |                |                |                |
| service        |                |                |                |
| announcement   |                |                |                |
| which is       |                |                |                |
| described in   |                |                |                |
| the clauses    |                |                |                |
| 7.5 and 7.6.   |                |                |                |
+----------------+----------------+----------------+----------------+

6.2 MBMS IoT profiles for file download delivery method
-------------------------------------------------------

### 6.2.0 Introduction

Clause L.4 in 3GPP TS 26.346 specifies the MBMS download profile for
both non-real-time (NRT) file delivery services as well as
DASH-formatted streaming services, using the FLUTE protocol. FLUTE uses
FDT instance to indicate the attributes and elements required for the
delivery. The FDT attributes and elements are categorized at the
FDT-Instance level (i.e., the *FDT-Instance* element of the FDT) and at
the File level (i.e., the *File* element of the FDT). The high-end IoT
category may reuse the MBMS download profile but does not require the
functionalities for multimedia services (e.g. DASH). Table 6.1-1 shows
the supported high-level capabilities in download delivery method for
IoT devices.

Table 6.2.0-1: Supported capabilities in download delivery method

+----------------+----------------+----------------+----------------+
|                | **Recommended  | Recommended    | MBMS profile   |
|                | for** Low-end  | for High-end   | in Annex L     |
|                | IoT category   | IoT category   | 3GPP TS 26.346 |
|                | profile        | profile        |                |
+----------------+----------------+----------------+----------------+
| FLUTE session  | No (Note 1)    | No (Note 1)    | Optional       |
| setup and      |                |                |                |
| control with   |                |                |                |
| RTSP           |                |                |                |
+----------------+----------------+----------------+----------------+
| SDP for        | FFS (Note 3)   | Yes            | Yes            |
| Download       |                |                |                |
| Delivery       |                |                |                |
| Method         |                |                |                |
+----------------+----------------+----------------+----------------+
| XML schema and | No (Note 2)    | FFS (Note 4)   | Yes            |
| processing     |                |                |                |
+----------------+----------------+----------------+----------------+
| NOTE 1: 3GPP   |                |                |                |
| TS 26.346      |                |                |                |
| clause L.4.6   |                |                |                |
| specifies      |                |                |                |
| \"FLUTE        |                |                |                |
| session setup  |                |                |                |
| and control    |                |                |                |
| with RTSP\" as |                |                |                |
| an option      |                |                |                |
| supported by   |                |                |                |
| the UE, IoT    |                |                |                |
| devices do not |                |                |                |
| require this   |                |                |                |
| functionality. |                |                |                |
|                |                |                |                |
| NOTE 2: In     |                |                |                |
| clause 5.3,    |                |                |                |
| low-end IoT    |                |                |                |
| category does  |                |                |                |
| not recommend  |                |                |                |
| full XML       |                |                |                |
| processing. A  |                |                |                |
| binary/json    |                |                |                |
| format may be  |                |                |                |
| defined for    |                |                |                |
| any XML data.  |                |                |                |
|                |                |                |                |
| NOTE 3: A      |                |                |                |
| solution for   |                |                |                |
| Low-end IoT    |                |                |                |
| profile could  |                |                |                |
| allow either   |                |                |                |
| the direct     |                |                |                |
| parsing of the |                |                |                |
| fields and     |                |                |                |
| attributes in  |                |                |                |
| the SDP file   |                |                |                |
| or the         |                |                |                |
| embedding of   |                |                |                |
| necessary      |                |                |                |
| fields and     |                |                |                |
| attributes in  |                |                |                |
| the SDP in the |                |                |                |
| service        |                |                |                |
| announcement   |                |                |                |
| using binary   |                |                |                |
| format         |                |                |                |
|                |                |                |                |
| NOTE 4: A      |                |                |                |
| solution for   |                |                |                |
| High-end IoT   |                |                |                |
| category       |                |                |                |
| profile could  |                |                |                |
| support either |                |                |                |
| XML format or  |                |                |                |
| binary format. |                |                |                |
+----------------+----------------+----------------+----------------+

### 6.2.1 Common FDT-Instance and File attributes for MBMS IoT profiles

Annex L4.2 in 3GPP TS 26.346 specifies the FDT attributes defined for
both the FDT-Instance and File levels. Table 6.2.1-1 shows the profiling
for each IoT category.

Table 6.2.1-1: Common FDT-Instance and File attributes for MBMS IoT
profiles

  ----------------------------------------------------------------- -------------------------------------------------- ----------------------------------------------- ----------------------------------------
  Attributes/Parameters                                             **Recommended for** Low-end IoT category profile   Recommended for High-end IoT category profile   MBMS profile in Annex L 3GPP TS 26.346
  Content-type                                                      Yes                                                Yes                                             Yes
  FEC-OTI-FEC-Encoding-ID                                           Yes                                                Yes                                             Yes
  FEC-OTI-Maximum-Source-Block-Length                               Yes                                                Yes                                             Yes
  FEC-OTI-Encoding-Symbol-Length                                    Yes                                                Yes                                             Yes
  FEC-OTI-Scheme-Specific-Info                                      Yes                                                Yes                                             Yes
  Content-Encoding                                                  No                                                 No                                              No
  FEC-OTI-FEC-Instance-ID                                           No                                                 No                                              No
  NOTE: The indicators YES and NO are specified for FLUTE sender.                                                                                                      
  ----------------------------------------------------------------- -------------------------------------------------- ----------------------------------------------- ----------------------------------------

### 6.2.2 FDT-Instance specific Elements and Attributes for MBMS IoT profiles

Table 6.2.2-1 shows the profiling for each IoT category on FDT-Instance
specific elements and attributes.

Table 6.2.2-1: FDT-Instance Specific Elements and Attributes for MBMS
IoT profiles

+----------------+----------------+----------------+----------------+
| Parameters     | **Recommended  | Recommended    | MBMS profile   |
|                | for** Low-end  | for High-end   | in Annex L     |
|                | IoT category   | IoT category   | 3GPP TS 26.346 |
|                | profile        | profile        |                |
+----------------+----------------+----------------+----------------+
| Expires        | Yes            | Yes            | Yes            |
+----------------+----------------+----------------+----------------+
| Complete       | No             | No             | No             |
+----------------+----------------+----------------+----------------+
| mb             | No             | No             | No             |
| ms2008:FullFDT |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2          | Yes (Note 1)   | Yes (Note 1)   | No             |
| 012:Base-URL-1 |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2          | Yes (Note 1)   | Yes (Note 1)   | No             |
| 012:Base-URL-2 |                |                |                |
+----------------+----------------+----------------+----------------+
| MBMS-Session-I | No             | No             | No             |
| dentity-Expiry |                |                |                |
+----------------+----------------+----------------+----------------+
| NOTE 1: The    |                |                |                |
| \"Base-URL-1\" |                |                |                |
| or             |                |                |                |
| \"Base-URL-2\" |                |                |                |
| elements are   |                |                |                |
| used for       |                |                |                |
| by             |                |                |                |
| te-range-based |                |                |                |
| file repair.   |                |                |                |
|                |                |                |                |
| NOTE 2: The    |                |                |                |
| indicators YES |                |                |                |
| and NO are     |                |                |                |
| specified for  |                |                |                |
| FLUTE sender.  |                |                |                |
+----------------+----------------+----------------+----------------+

### 6.2.3 FDT File specific Elements and Attributes for MBMS IoT profiles

Table 6.2.3-1 shows the profiling for each IoT category on FDT File
specific elements and attributes.

Table 6.2.3-1: FDT File specific Elements and Attributes for MBMS IoT
profiles

+----------------+----------------+----------------+----------------+
| Parameters     | **Recommended  | Recommended    | MBMS profile   |
|                | for** Low-end  | for High-end   | in Annex L     |
|                | IoT category   | IoT category   | 3GPP TS 26.346 |
|                | profile        | profile        |                |
+----------------+----------------+----------------+----------------+
| Co             | Yes            | Yes            | Yes            |
| ntent-Location |                |                |                |
+----------------+----------------+----------------+----------------+
| TOI            | Yes            | Yes            | Yes            |
+----------------+----------------+----------------+----------------+
| Content-Length | Yes            | Yes            | Yes            |
+----------------+----------------+----------------+----------------+
| Content-MD5    | Yes            | Yes            | Yes            |
+----------------+----------------+----------------+----------------+
| mbms2007       | No (Note 2)    | Yes            | Yes            |
| :Cache-Control |                |                |                |
+----------------+----------------+----------------+----------------+
| Content-type   | Yes            | Yes            | Yes            |
+----------------+----------------+----------------+----------------+
| FEC-OTI-F      | Yes            | Yes            | Yes            |
| EC-Encoding-ID |                |                |                |
+----------------+----------------+----------------+----------------+
| FEC-OTI        | Yes            | Yes            | Yes            |
| -Maximum-Sourc |                |                |                |
| e-Block-Length |                |                |                |
+----------------+----------------+----------------+----------------+
| FE             | Yes            | Yes            | Yes            |
| C-OTI-Encoding |                |                |                |
| -Symbol-Length |                |                |                |
+----------------+----------------+----------------+----------------+
| FEC-OTI-Ma     | Yes            | Yes            | Yes            |
| x-Number-of-En |                |                |                |
| coding-Symbols |                |                |                |
+----------------+----------------+----------------+----------------+
| FEC-OTI-Scheme | Yes            | Yes            | Yes            |
| -Specific-Info |                |                |                |
+----------------+----------------+----------------+----------------+
| T              | No (Note 1)    | Yes (Note 1)   | No (Note 1)    |
| ransfer-Length |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2009:Decr  | No             | No             | No             |
| yption-KEY-URI |                |                |                |
+----------------+----------------+----------------+----------------+
| m              | No             | No             | No             |
| bms2012:FEC-Re |                |                |                |
| dundancy-Level |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2012:      | Yes            | Yes            | No             |
| Alternate-Cont |                |                |                |
| ent-Location-1 |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2012:      | Yes            | Yes            | No             |
| Alternate-Cont |                |                |                |
| ent-Location-2 |                |                |                |
+----------------+----------------+----------------+----------------+
| MBMS-Se        | No             | No             | No             |
| ssion-Identity |                |                |                |
+----------------+----------------+----------------+----------------+
| NOTE 1: IoT    |                |                |                |
| devices may    |                |                |                |
| not use gzip   |                |                |                |
| content        |                |                |                |
| encoding,      |                |                |                |
| T              |                |                |                |
| ransfer-Length |                |                |                |
| may not be     |                |                |                |
| useful.        |                |                |                |
|                |                |                |                |
| NOTE 2: eMBMS  |                |                |                |
| client can     |                |                |                |
| ignore any     |                |                |                |
| cache-control  |                |                |                |
| directive. For |                |                |                |
| instance, an   |                |                |                |
| eMBMS client   |                |                |                |
| may remove     |                |                |                |
| from its cache |                |                |                |
| any file       |                |                |                |
| received as    |                |                |                |
| soon as the    |                |                |                |
| MBMS           |                |                |                |
| application    |                |                |                |
| has acquired   |                |                |                |
| the file.      |                |                |                |
|                |                |                |                |
| NOTE 3: The    |                |                |                |
| indicators YES |                |                |                |
| and NO are     |                |                |                |
| specified for  |                |                |                |
| FLUTE sender.  |                |                |                |
+----------------+----------------+----------------+----------------+

Signalling of parameters with basic ALC/FLUTE headers or FLUTE extension
headers for IoT device categories is the same as specified in clauses
7.2.7 and 7.2.8 of 3GPP TS 26.346.

### 6.2.4 3GPP-defined FDT extensions for MBMS IoT profiles

3GPP TS 26.346 defines various FDT elements and attributes specified for
3GPP MBMS User Services that are not in the FLUTE specified in RFC 3926
\[3\]. Table 6.2.4-1 shows the profiling of these elements and
attributes for MBMS IoT profiles.

Table 6.2.4-1: 3GPP-defined FDT extension elements for MBMS IoT profiles

+----------------+----------------+----------------+----------------+
| Parameters     | Recommended    | Recommended    | MBMS profile   |
|                | for Low-end    | for High-end   | in Annex L     |
|                | IoT category   | IoT category   | 3GPP TS 26.346 |
|                | profiles       | profiles       |                |
+----------------+----------------+----------------+----------------+
| mbms200        | No             | No             | No             |
| 5:MBMS-Session |                |                |                |
| -Identity-Type |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2005:MBMS- | No             | No             | No             |
| Session-Identi |                |                |                |
| ty-Expiry-Type |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms20         | No             | No             | No             |
| 05:groupIdType |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2007       | No             | No             | No             |
| :Cache-Control |                |                |                |
+----------------+----------------+----------------+----------------+
| mb             | No             | No             | No             |
| ms2008:FullFDT |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2009:Decr  | No             | No             | No             |
| yption-KEY-URI |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2          | No             | No             | No             |
| 012:Base-URL-1 |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2          | No             | No             | No             |
| 012:Base-URL-2 |                |                |                |
+----------------+----------------+----------------+----------------+
| m              | No             | No             | No             |
| bms2012:FEC-Re |                |                |                |
| dundancy-Level |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2012:      | No             | No             | No             |
| Alternate-Cont |                |                |                |
| ent-Location-1 |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2012:      | No             | No             | No             |
| Alternate-Cont |                |                |                |
| ent-Location-2 |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms           | Yes (Note 1)   | Yes            | Yes            |
| 2012:File-ETag |                |                |                |
+----------------+----------------+----------------+----------------+
| mbms2          | No             | No             | No             |
| 015:Independen |                |                |                |
| tUnitPositions |                |                |                |
+----------------+----------------+----------------+----------------+
| MBMS-Session-I | No             | No             | No             |
| dentity-Expiry |                |                |                |
+----------------+----------------+----------------+----------------+
| NOTE 1: CoAP   |                |                |                |
| supports Etag  |                |                |                |
| option.        |                |                |                |
|                |                |                |                |
| NOTE 2: The    |                |                |                |
| indicators YES |                |                |                |
| and NO are     |                |                |                |
| specified for  |                |                |                |
| FLUTE sender.  |                |                |                |
+----------------+----------------+----------------+----------------+

For Low-end IoT category profile, the attributes and elements in the FDT
described in the Tables 6.2.1-1, 6.2.2-1, 6.2.3-1 and 6.2.4-1 could be
embedded in the service announcement.

7 Solutions
===========

7.1 Overview of CoAP
--------------------

### 7.1.0 General

This clause provides an overview of CoAP, whose design was motivated for
IoT-related communications. As described in RFC 7252 \[7\], it is a
specialized content transfer protocol for the Internet for use with
constrained endpoints and constrained networks (e.g. low-power Tx/Rx and
bandwidth). CoAP supports a request/response interaction model between
application endpoints and includes key Web concepts in HTTP such as
RESTful client-server architecture, use of URIs for resource
identification and location, and Internet media types. In fact, CoAP is
designed to interface easily with HTTP for Web integration while meeting
specific requirements such as very low overhead, simplicity for
constrained application, device and network environments (such as in IoT
communications). It also contains built-in support for service and
resource discovery, as well as multicast distribution (since it runs
over UDP, it also supports the use of multicast IP destination
addressing). The key characteristics and features of CoAP can be
summarized as follows:

\- Web protocol which fulfils IoT/M2M requirements in constrained
environments;

\- Binding to UDP transport with optional reliable delivery;

\- Support for both unicast and multicast requests;

\- Asynchronous message exchanges;

\- Small, simple header \< 10 bytes;

\- URI-based resource location/addressing and content type support;

\- Simple proxy and caching capabilities;

\- Stateless HTTP mapping, enabling both the use of proxies to provide
access to CoAP resources using HTTP in a uniform way, and simple HTTP
interfaces to be alternatively implemented over CoAP;

\- Security binding to DTLS (Datagram Transport Layer Security;

\- Optional observation, block transfer and discovery.

The relationship between the use of and interworking between HTTP and
CoAP as Web transfer protocols in the REST-based architecture
environment is shown in Figure 7.1.0-1 below:

Figure 7.1.0-1: Interworking between HTTP and CoAP

### 7.1.1 Comparison to HTTP

Like HTTP, CoAP was designed with the REST architecture popular in the
Web in mind in support of the ubiquitous use on the Internet of Web
services/Web APIs by applications. As opposed to simply employing
compression of HTTP, the design of CoAP intended to realize a subset of
REST common with HTTP but optimized for IoT or M2M applications. The
interaction model of CoAP is similar to the client/server model in HTTP.
A CoAP request, as in HTTP, is sent by a client to a server to request
an action, via a *Method Code* on the server-resident resource.
Subsequently, the server returns a response (with associated *Response
Code*) which may include a payload containing a representation of the
requested resource. However, unlike HTTP, such interactions operate
asynchronously in CoAP, over the datagram-based transport offered by
UDP. Other similarities in features to HTTP as offered in CoAP include:

a\) signalling of additional metadata in both request or responses in
the form of *Options* carried in the CoAP message header, similar to the
use of Header fields in HTTP;

b\) support for proxying and caching as in HTTP;

c\) enables securing the message exchange between CoAP endpoints by use
of DTLS, which functions like TLS in HTTPS.

### 7.1.2 Logical Architecture Model

#### 7.1.2.0 General

CoAP can be considered logically as a two-layer operational model
comprising: i) request/response interaction layer using *Method* and
*Response* codes, and whose contents are carried by messages and ii) a
message layer that addresses the underlying UDP transport and the
asynchronous nature of the client-server interactions. This model is
shown below in Figure 7.1.2.0-1.

Figure 7.1.2.0-1: Logical Layered Model of CoAP

#### 7.1.2.1 CoAP Messaging Model

CoAP messages uses a short fixed-length binary header (4 bytes) that may
be followed by compact binary options and a payload. This message format
is shared by requests and responses. Each CoAP message contains a
Message ID for duplicate-detection and support of optional reliability.
CoAP defines four types of messages:

\- Confirmable (CON),

\- Non-confirmable (NON),

\- Acknowledgement (ACK), and

\- Reset (RST).

Requests can be carried in either Confirmable or Non-confirmable
messages, and responses can be carried in these or could be piggybacked
in Acknowledgement messages. The use of Confirmable messages adds
reliability to UDP transport, since messages marked as such (CON) will
be retransmitted (using a default time-out and exponential back-off
between retransmissions) until the recipient returns an ACK message with
the same Message ID. An example of reliable CoAP messaging is shown in
Figure 7.1.2.1-1.

Figure 7.1.2.1-1: Reliable Message Transmission in CoAP

The response to a CON message could be sent initially as an empty ACK
message (as shown by the second step of the call flow in the right-hand
side diagram in Figure 7.1.2.1-1), and later, when the resource becomes
available, it can be carried as the payload of a second response via a
separate CON message (as shown by the third step of the call flow in the
right-hand side diagram in Figure 7.1.2.1-1). This is referred to as a
\"separate response\". The latter response can be linked to the original
request using a *Token* in both the request and response messages to
identify their correlation independently from the underlying message
exchanges. An example of piggybacked and separated responses (separated
delivery of ACK from payload) is show in Figure 7.1.2.1-2.

Figure 7.1.2.1-2: Piggybacked vs. Separated Response for Reliable
Messaging in CoAP

Should a recipient be unable to process a CON message, it will reply
with a Reset message (RST) instead of an ACK. Messages not requiring
reliable delivery can be sent as Non-Confirmable (NON) messages. Such
message will not be acknowledged, but will contain a Message ID for
duplicate detection. If a request is sent in a NON message, its response
may be returned in a new NON message, an example of which is shown in
Figure 7.1.2.1-3, or a CON message can be returned (requiring the peer
to return an ACK). A recipient that is unable to process a NON message
may reply with a RST message.

Figure 7.1.2.1-3: Request and Response via Separate Non-Confirmable
Messages

#### 7.1.2.2 Methods and Response Codes

CoAP makes use of GET, PUT, POST, and DELETE methods in a manner similar
to HTTP, with the semantics described below:

\- GET: retrieves a representation for the information that currently
corresponds to the resource identified by the request URI.

\- PUT: requests that the resource identified by the request URI be
updated or created with the attached representation.

\- POST: requests processing of the enclosed representation in the
request.

\- DELETE: requests that the resource identified by the request URI be
deleted.

Methods beyond the basic four types can be added to CoAP in separate
IETF specifications. URI support in a server is simplified as the client
already parses the URI and splits it into host, port, path, and query
components, making use of default values for efficiency. Response Codes
relate to a small subset of HTTP status codes along with a few
CoAP-specific codes, with some examples as shown in Clause 7.1.3.

After receiving and interpreting a request, a server responds with a
CoAP response that is matched to the request by the client-generated
token whose purpose is different from the Message ID (the latter is used
to match a Confirmable message to its Acknowledgement). A response is
identified by the Code field in the CoAP header as defined in
Clause 7.1.3. Like the HTTP Status Code, the CoAP Response Code
indicates the result of the target endpoint\'s attempt to understand and
satisfy the request.

### 7.1.3 Message Format

CoAP features the delivery of compact message delivery over UDP. CoAP
messages are encoded in a simple binary format. The message format
starts with a fixed-size 4-byte header. This is followed by a
variable-length Token value, which can be between 0 and 8 bytes long.
After the Token is a sequence of zero or more CoAP *Options* in
Type-Length-Value (TLV) format, optionally followed by a payload that
occupies the data clause of the datagram. The CoAP message format is
shown below in Figure 7.1.3-1.

Figure 7.1.3-1: CoAP Message Header

\- Ver (V): message Version number

\- Type (T): message Type -- CON (00), NON (01), ACK (10), RST (11)

\- Token Length (TKL): length of (variable-length) Token field whose
value is a sequence of 0 to 8 bytes. The Token value, acting effectively
as a \"request ID\" is used to correlate requests and responses, as
every request will contain a client-generated Token that the server will
echo (without modification) in any resulting response.

\- Code: A 3-digit code in the form c.dd, where \'c\' is 3-bit \'class\'
representing a single decimal digit from 0-7, and \'dd\' is a 5-bit
\'detail\' representing two decimal digits from 00 to 31. The class can
indicate a Request (0), a Success response (2), a Client Error response
(4), or a Server Error response (5). As example values of the \'Code\'
field, the following Success and Client Error codes are defined:

> **Success codes (2.xx):**

*- 2.01 Created*: similar to HTTP 201 \"Created\", but only used in
response to POST and PUT requests. The payload returned with the
response, if any, is a representation of the action result.

*- 2.02 Deleted*: similar to HTTP 204 \"No Content\" but only used in
response to a request that causes the resource to be no longer
available, such as DELETE and, in certain circumstances, POST requests.

*- 2.03 Valid*: similar to HTTP 304 \"Not Modified\", but is only used
to indicate that the response identified by the entity-tag identified by
the included ETag Option is valid.

*- 2.04 Changed*: similar to HTTP 204 \"No Content\" but only used in
response to POST and PUT requests.

*- 2*.*05 Content*: similar to HTTP 200 \"OK\" but only used in response
to GET requests.

> **Client Error codes (4.xx):**

*- 4.00 Bad Request*: Equivalent meaning to HTTP 400 \"Bad Request\".

*- 4.01 Unauthorized*: the client is not authorized to perform the
requested action.

*- 4.02 Bad Option*: the request could not be understood by the server
due to one or more *unrecognized* or malformed options.

\- Each of the following error codes *4.03 Forbidden*, *4.04 Not Found*,
*4.05 Method Not Allowed*, *4.06 Not Acceptable*, *4.12 Precondition
Failed*, *4.13 Request Entity Too Large*, and *4.15 Unsupported
Content-Format* has similar semantics to its HTTP 4.xx error code
counterpart with the same \'xx\' value.

\- Message ID: use for matching response type ACK/RST to request type
CON/NON, as well as for message duplicate detection.

While the CoAP specification \[7\] itself only defines an upper bound to
the message size. Messages larger than an IP packet would result in
undesirable packet fragmentation. Therefore, \[7\] recommends that when
appropriately encapsulated, a CoAP message can fit within a single IP
packet and which fits into one UDP packet payload, i.e. within a single
IP datagram.

### 7.1.4 Options

Either a request or response message may contain one or more options, a
common set of which is defined in CoAP for both message types:

\- Content-Format

\- ETag

\- Location-Path

\- Location-Query

\- Max-Age

\- Proxy-Uri

\- Proxy-Scheme

\- Uri-Host

\- Uri-Path

\- Uri-Port

\- Uri-Query

\- Accept

\- If-Match

\- If-None-Match

\- Size1

As can be seen, many of these options have the same name and similar
semantics as header fields defined in HTTP. Options belong to one of two
classes: \"critical\" or \"elective\". The difference is how an
unrecognizable option is handled by the message recipient, namely
according to the following rules:

\- Unrecognized options of class \"elective\" will be silently ignored;

\- Unrecognized options of class \"critical\" that occur in a CON
request will cause the return of a 4.02 (Bad Option) response;

\- Unrecognized options of class \"critical\" that occur in a CON
response, or piggybacked in an ACK response, will cause the response to
be rejected;

\- Unrecognized options of class \"critical\" that occur in a NON
message will cause the message to be rejected.

Additionally, options are also classified based on how a proxy is to
deal with an option it does not recognize it. For this purpose, an
option can either be considered \'Unsafe-to-Forward\' (*UnSafe* is set
to 1) or \'Safe-to-Forward\' (*UnSafe* is set to 0).

### 7.1.5 Caching

CoAP endpoints may be able to cache responses to reduce the response
time and network bandwidth consumption on future, equivalent requests.
Unlike HTTP, the cache ability of a CoAP response does not depend on the
request method, but instead on the Response Code. A \"freshness\"
mechanism is used for this purpose by making of the \'Max-Age\' Option
code, which indicates the cache lifetime. The \'ETag\' Option allows for
validity checking whereby the payload of a prior response can be reused
to satisfy a new request. RFC 7252 \[7\] indicates that Response Codes
used to indicate success but are unrecognized by an endpoint will not be
cached.

### 7.1.6 Proxying

As possible in HTTP, CoAP supports the use of proxies which are CoAP
devices typically used by clients to perform requests on their behalf.
Both *forward-proxy* and *reverse-proxy* functionality are possible. In
the former, the proxy can be explicitly selected by the client in
serving the client\'s request, whereas in the latter, the proxy serves
as stand-in for an origin server. A proxy can map an incoming CoAP
request to an outgoing CoAP request (CoAP-to-CoAP proxy), or translate
from/to a different protocol (\"cross-proxy\"), for example, between
CoAP and HTTP. An instance of such CoAP-to-HTTP cross proxy is shown in
Figure 7.1-1.

### 7.1.7 Security and DTLS

The delivery of CoAP messages can be secured by using DTLS (Datagram
Transport Layer Security) as defined in RFC 6347 \[8\], in a similar
fashion to securing HTTP over TCP by using TLS. The CoAP protocol stack
model with the (optional) inclusion of DTLS was shown in Figure 7.1.2-1.

### 7.1.8 Block-wise transfers

#### 7.1.8.0 General

The CoAP base protocol works well for small payload. However, in case of
larger payload which exceeds the maximum size for fragmentation at
different layers (e.g. IP, UDP), RFC 7959 \[13\] extends basic CoAP with
a pair of \"Block\" options for transferring multiple blocks of
information from a resource representation in multiple request-response
pairs. RFC 7959 \[13\] suggests to limit the size of datagrams in
constrained networks:

\- by the maximum datagram size (\~ 64 KiB for UDP)

\- by the desire to avoid IP fragmentation (MTU of 1280 bytes for IPv6)

\- by the desire to avoid adaptation-layer fragmentation (60-80 bytes
for 6LoWPAN \[12\])

NOTE: KiB = 1024 bytes.

The block-wise specification adds a pair of Block options (Block1 and
Block2) to CoAP that can be used for block-wise transfers. Both options
can be present in both the request and response messages. In either
case, the Block1 Option pertains to the request payload, and the Block2
Option pertains to the response payload. Benefits of using these options
include:

\- Transfers larger than what can be accommodated in constrained-network
link-layer packets can be performed in smaller blocks.

\- No hard-to-manage conversation state is created at the adaptation
layer or IP layer for fragmentation.

\- The transfer of each block is acknowledged, enabling individual
retransmission if required. Both sides have a say in the block size that
actually will be used.

\- The resulting exchanges are easy to understand using packet analyser
tools, and thus quite accessible to debugging.

\- If needed, the Block options can also be used (without changes) to
provide random access to power-of-two sized blocks within a resource
representation.

#### 7.1.8.1 Structure of a Block Option

Three items of information may need to be transferred in a Block (Block1
or Block2) option:

\- the size of the block (SZX);

\- whether more blocks are following (M);

\- the relative number of the block (NUM) within a sequence of blocks
with the given size.

The value of the Block option is a variable-size (0 to 3 byte) unsigned
integer. This integer value encodes these three fields, see Figure
7.1.8.1-1.

![](media/image9.png){width="4.088888888888889in"
height="2.7263888888888888in"}

Figure 7.1.8.1-1: Block Option Value

The block size is encoded using a three-bit unsigned integer (0 for
2\*\*4 bytes to 6 for 2\*\*10 bytes), called the \"SZX\" (\"size
exponent\"); the actual block size is then \"2\*\*(SZX + 4)\".

The bit M or \"more\" bit, indicates whether more blocks are following
or if the current block-wise transfer is the last block being
transferred.

The option value divided by sixteen (the NUM field) is the sequence
number of the block currently being transferred, starting from zero. The
current transfer is, therefore, about the \"size\" bytes starting at
byte \"NUM \<\< (SZX + 4)\".

More specifically, within the option value of a Block1 or Block2 Option,
the meaning of the option fields is defined as follows:

NUM: Block Number, indicating the block number being requested or
provided. Block number 0 indicates the first block of a body (i.e.,
starting with the first byte of the body).

M: More Flag (\"not last block\"). For descriptive usage, this flag, if
unset, indicates that the payload in this message is the last block in
the body; when set, it indicates that there are one or more additional
blocks available. When a Block2 Option is used in a request to retrieve
a specific block number (\"control usage\"), the M bit will be sent as
zero and ignored on reception. (In a Block1 Option in a response, the M
flag is used to indicate atomicity, see below.)

SZX: Block Size. The block size is represented as a three-bit unsigned
integer indicating the size of a block to the power of two. Thus, block
size = 2\*\*(SZX + 4). The allowed values of SZX are 0 to 6, i.e., the
minimum block size is 2\*\*(0+4) = 16 and the maximum is 2\*\*(6+4) =
1024. The value 7 for SZX (which would indicate a block size of 2048) is
reserved, the detailed behaviour is referred to RFC 7959 \[13\].

NOTE: The bit order (e.g. most or least significant bits) are specified
in RFC 7959 \[13\].Table 7.1.8.1-1 shows the CoAP options including
Block1 and Block2 with numbers 27 and 23, respectively.

![](media/image10.png){width="5.950694444444444in"
height="4.250694444444444in"}

Table 7.1.8.1-1: Block Option Numbers

7.2 Overview of LwM2M
---------------------

Lightweight M2M (LwM2M) \[9\] is a system standard defined by Open
Mobile Alliance (OMA). As with other device management standards (e.g.
OMA DM), LwM2M solution is called an Enabler. LwM2M Enabler defines the
application layer communication protocol between a LwM2M Server and a
LwM2M Client. The LwM2M Server resides in a private or public data
centre and can be hosted by the M2M Service Provider, Network Service
Provider or Application Service Provider while the LwM2M Client resides
on the device. The target LwM2M Devices are mainly resource constrained
devices. The key features of LwM2M 1.0 Enabler can be summarized as
follows:

\- Simple resource model with the core set of objects and resources
defined in the present document.

\- Operations for creation, update, deletion, and retrieval of
resources.

\- Asynchronous notifications of resource changes.

\- Support for several serialization formats, namely TLV, JSON, Plain
Text and binary data formats and the core set of LightweightM2M Objects.

\- UDP and SMS transport support.

\- Communication security based on the DTLS protocol supporting
different types of credentials.

\- Queue Mode offers functionality for a LwM2M Client to inform the
LwM2M Server that it may be disconnected for an extended period and when
it becomes reachable again.

\- Support for use of multiple LwM2M Servers.

\- Provisioning of security credentials and access control lists by a
dedicated LwM2M bootstrap-server.

LwM2M employs a client-server architecture plus CoAP with UDP/SMS
transport binding as shown in Figure 7.2-1 while the protocol stack is
shown in Figure 7.2-2. The LwM2M Enabler has two components, LwM2M
Server and LwM2M Client. Four interfaces are designed between these two
components as shown below:

\- Bootstrap: is used to provision essential information into the LwM2M
Client to enable the LwM2M Client to perform the operation \"Register\"
with one or more LwM2M Servers. Bootstrap interface also allows LwM2M
Bootstrap Server to manage the keying, access control and configuration
of a device.

\- Client Registration: is used by a LwM2M Client to register its
capabilities with one or more LwM2M Servers, maintain each registration
and de-register from a LwM2M Server.

\- Device management and service enablement: allows the LwM2M Server to
perform device management and M2M service enablement by sending
operation to the Client and to get corresponding response from the LwM2M
Client.

\- Information Reporting: is used by a LwM2M Server to observe any
changes in a Resource on a registered LwM2M Client, receiving
notifications when new values are available.

![](media/image11.wmf){width="3.158333333333333in"
height="3.745138888888889in"}

Figure 7.2-1: The overall architecture of the LwM2M Enabler

![](media/image12.wmf){width="3.609722222222222in" height="2.24375in"}

Figure 7.2-2: The protocol stack of the LwM2M Enabler

The LwM2M Enabler defines a simple resource model where each piece of
information made available by the LwM2M Client is a Resource. The
Resources are further logically organized into Objects, and each
Resource is given a unique identifier within that Object.

Figure 7.2-3 illustrates the relationship between Resources, Objects and
the LwM2M Client. The LwM2M Client can have any number of Resources,
each of which belongs to an Object. For example, the Firmware Object
contains all the Resources used for firmware update purposes.

![](media/image13.wmf){width="3.183333333333333in"
height="3.4583333333333335in"}

Figure 7.2-3: Relationship between LwM2M Client, Object, and Resources

OMA LwM2M Enabler version 1.0 also specifies a set of 8 Device
Management‐oriented Objects:

0: Security Object ‐ handles security aspects between LwM2M Client and
Server

1: Server ‐ defines data and functions related to the LwM2M Server

2: Access Control ‐ defines the access rights which can be granted on
Client Objects for a given Server

3: Device ‐ details device specific information

4: Firmware ‐ details resources on the device useful for firmware
upgrades

5: Location ‐ groups resources providing information about the device
current location

6: Connectivity Monitoring ‐ groups resources that assist in monitoring
the status of a network connection

\- 7: Connection Statistics ‐ groups resources that hold statistical
information about an existing network connection

7.3 Solutions for File Repair using CoAP
----------------------------------------

### 7.3.0 General

3GPP TS 26.346 clause 9.3 describes two file repair procedures for MBMS
User Services: the symbol-based procedure and the byte-range-based
procedure. In byte-range-based message format, the MBMS UE uses the
conventional HTTP/1.1 GET or partial GET requests as defined in RFC 2616
to request all or a subset of source symbols of the referenced resource,
respectively. Low-end IoT device category may not equipped with HTTP
stack to keep a small code size. This clause describes the solutions for
File Repair based on CoAP. It comprises two categories of file repair
mechanisms which are similar in the use of a generic CoAP server that is
AL-FEC unaware, as the file repair server. From that standpoint (i.e.,
AL-FEC unawareness of the CoAP file repair server), both categories, as
described below in sub-clauses 7.3.1 and 7.3.2, could be considered as
representing byte-ranged based file repair mechanisms according to the
semantics in TS 26.346, since the requests for repair data from the CoAP
client are devoid of FEC symbol semantics. They differ in the way the
MBMS receiver/CoAP client performs the CoAP requests for repair data:

*1) Requests for byte ranges*, whereby the CoAP client specifies a byte
range of the original file stored on the CoAP server to be returned by
the server;

*2) Requests for CoAP Blocks*, whereby the CoAP client specifies one or
more blocks of data, in the manner of block-wise transfer in CoAP as
defined in RFC 7959 \[13\].

### 7.3.1 Byte-Range Request based File Repair

#### 7.3.1.0 General

The CoAP base protocol \[7\] does not define the option that has an
equivalent functionality as Range in HTTP header. This solution provides
two alternative options to address the byte-range request based file
repair.

The byte-range request based solutions comprise the following two
options:

\- The option 1 provides a solution using the existing Uri-Query option
defined in CoAP. It can be done without any changes in the CoAP IETF
standard.

> \- The option 2 defines a new CoAP option Range. This solution
> requires a change in the CoAP IETF standard

#### 7.3.1.1 Option 1: use Uri-Query option in CoAP

This alternative relies on the use of Uri-Query option in CoAP to send a
byte-range request message. This solution uses the special defined
keywords \"bytefrom\" and \"byteto\" inside Uri-Query option to indicate
the byte-range.

NOTE 1: The special defined keywords could be different than
\"bytefrom\" and \"byteto\" if this option is adopted.

As an example, the FLUTE receiver partially receives the transport
object with file name \"firmware.bin\" having the \"File-Etag\"
attribute set to \"df69d20220cb1ff4\" in the FDT instance. It issues a
repair request to the host server to fetch the missing bytes. The
request message from the CoAP client is as follows:

Input:

Destination IP Address = 198.51.100.1

Destination UDP Port = 5683

Uri-Host = \"mbmsrepair1.example.com\"

Etag = \"df69d20220cb1ff4\"

Uri-Path = \"path\"

Uri-Path = \"repair\_script\"

Uri-Query = \"bytefrom=500;byteto=627\"

Output:

coap://mbmsrepair1.example.com:5683/path/repair\_script/?bytefrom=500;byteto=627

NOTE 2: The Etag option does not appear in the CoAP URI but in the CoAP
payload.

Upon reception of the GET request message, the CoAP server parses the
special keywords \"bytefrom\", \"byteto\" to extract the byte-range the
CoAP client wants to fetch. Figure 7.3.1.1-1 shows the request and
response CoAP messages.

![](media/image14.png){width="6.690972222222222in"
height="1.7916666666666667in"}

Figure 7.3.1.1-1: Request and response CoAP messages using Uri-Query
option

NOTE 3: MID is the message ID in CoAP header.

In 3GPP TS 26.346, multiple byte-ranges or multiple symbols in different
block number can be put in a single HTTP based file repair request
message. However, there is no benefits to combining multiple requests in
a single request message in CoAP since transfer of each block is
acknowledged \[13\]. If the missing data in a response message is large,
or if the CoAP server wants to use multiple small data payloads in
response messages, the block-wise transfer is used. Table 7.3.1.1-1
shows different cases for byte-range request:

Table 7.3.1.1-1: Different cases for CoAP byte-range request message

+----------------------+----------------------------------------------+
| Single byte-range    | Single response CoAP message for file repair |
|                      | if possible                                  |
|                      |                                              |
|                      | Otherwise use block-wise transfer            |
+----------------------+----------------------------------------------+
| Multiple byte-ranges | Split into multiple of single byte-range     |
|                      | requests                                     |
+----------------------+----------------------------------------------+

Figure 7.3.1.1-2 shows the case where the CoAP server wants to use
block-wise transfer to deliver the missing bytes.

![](media/image15.png){width="6.690972222222222in"
height="2.9118055555555555in"}

Figure 7.3.1.1-2: Request response CoAP messages using block-wise

NOTE 4: MID is the message ID in CoAP header.

#### 7.3.1.2 Option 2: define a new CoAP option Range

A new CoAP option \"Range\" with a new allocated number 21 is defined in
this solution. Table 7.3.1.2-1 shows an example where the \"Range\"
option resides in the ordered options in CoAP.

Table 7.3.1.2-1: New defined \"Range\" option within **CoAP options**

  -------------------------------------------------- --- --- ---- --- ---------------- -------- -------- -------------
  No.                                                C   U   N    R   Name             Format   Length   Default
  1                                                  x            x   If-Match         opaque   0-8      (none)
  3                                                  x   x   \-       Uri-Host         string   1-255    (see below)
  4                                                               x   ETag             opaque   1-8      (none)
  5                                                  x                If-None-Match    empty    0        (none)
  7                                                  x   x   \-       Uri-Port         unit     0-2      (see below)
  8                                                               x   Location-Path    string   0-255    (none)
  11                                                 x   x   \-   x   Uri-Path         string   0-255    (none)
  12                                                                  Content-Format   unit     0-2      (none)
  14                                                     x   \-       Max-Age          unit     0-4      60
  15                                                 x   x   \-   x   Uri-Query        string   0-255    (none)
  17                                                 x                Accept           unit     0-2      (none)
  20                                                              x   Location-Query   string   0-255    (none)
  21                                                     x        x   Range            string   0-255    (none)
  35                                                 x   x   \-       Proxy-Uri        string   1-1034   (none)
  39                                                 x   x   \-       Proxy-Scheme     string   1-255    (none)
  60                                                         x        Size1            unit     0-4      (none)
  C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable                                                       
  -------------------------------------------------- --- --- ---- --- ---------------- -------- -------- -------------

NOTE 1: This solution uses the option number 21 to demonstrate the
feasibility of the solution. If this solution using \"Range\" option is
adopted as an extension of CoAP protocol, the allocated number could be
different.

With the new defined CoAP option, the query message from the CoAP client
is as follows:

Input:

Destination IP Address = 198.51.100.1

Destination UDP Port = 61616

Uri-Host = \"mbmsrepair1.example.com\"

Etag = \"df69d20220cb1ff4\"

Uri-Path = \"path\"

Uri-Path = \"repair\_script\"

Range = \"bytes=500-627\"

Output:

coap://mbmsrepair1.example.com:5683/path/repair\_script/

NOTE 2: The Etag and Range options do not appear in the CoAP URI but in
the CoAP payload since these options are not in the process of the
clause 6.5 of RFC 7252.

Figure 7.3.1.2-1 shows the request response CoAP messages using the new
defined \"Range\" option.

![](media/image16.png){width="6.690972222222222in"
height="1.7916666666666667in"}

Figure 7.3.1.2-1: Request and response CoAP messages using defined
\"Range\" option

Similarly, Figure 7.3.1.2-2 shows the case where the CoAP server wants
to use block-wise transfer to deliver the missing bytes.

![](media/image17.png){width="6.690972222222222in"
height="2.9118055555555555in"}

Figure 7.3.1.2-2: Request and response CoAP messages using defined
\"Range\" option and block-wise

### 7.3.2 Block Request based File Repair

#### 7.3.2.0 General

Two alternatives for block request based file repair via CoAP are
described in this clause. They are motivated by and modeled after
similar options in byte-range based file repair, as described in 3GPP TS
26.346, clause 9.3.6.2. Specifically, they are based on the two options
available to the BM-SC for delivering FEC encoding symbols using the
download delivery method:

\- Sending of source symbols followed by repair symbols, and

\- Sending of repair symbols exclusively.

For the sake simplicity in the following examples, it is assumed that
sub-blocking is not used in the broadcast transmission of FEC symbols.
Also, it is assumed that the original file object is stored on a
standard CoAP server that supports file repair, and which is
FEC-unaware.

#### 7.3.2.1 Option 3: Block request for repair data after broadcast transmission of source and repair symbols 

In the example as shown below in Figure 7.3.2.1-1, broadcast delivery of
the file object comprises sending of the source symbols followed by
repair symbols. It is assumed that the file object for broadcast
delivery to MBMS-capable IoT devices is a firmware update file whose
size is 6.7 Kbytes. The BM-SC will apply AL-FEC in the transmission of
the file object, encoded as source symbols, along with the repair
symbols generated from the file, as a sequence of ALC/ FLUTE packets,
each with payload size of 1024 bytes.

Figure 7.3.2.1-1: MBMS download delivery of 6.7-kByte file employing
256-byte FEC symbols carried in FLUTE packets with payload size of 1024
bytes; sending of source + repair symbols

In FLUTE delivery of the file, an integer number of FEC encoding symbols
are contained in the 1024-byte packet payload -- in this example, four
256-byte FEC symbols are carried in each FLUTE packet. Loss in reception
of any FLUTE packet, due to for example transmission errors, would
result in a loss of four symbols (for packets not containing padding
bytes). The UE will track the number of symbols it has successfully
acquired, and determine the specific additional symbols needed for
successful FEC decoding. As shown in the above example, FEC symbols
which map logically to Blocks 1, 5 and 6 of the source file (along with
some repair symbols) were not received, corresponding to the loss of
source symbols with ESIs (Encoded Symbol IDs) 4-7 and 20-26. Suppose
that in this example, eleven additional symbols are needed to enable
full file recovery. The MBMS client will determine that source symbols
with ESIs 4-7, 20-23, and 24-26, corresponding to Blocks 1 and 5, and a
portion of Block 6, will need to be acquired via unicast file repair.
Subsequently, the UE will employ CoAP\'s Block2 option to request, via
the GET method, block-wise transfer from the server of those symbols, as
shown in Figure 2.

Figure 7.3.2.1-2: Block-wise transfer request and response for retrieval
of FEC symbols contained in Blocks 1 and 5 at repair server

Note that in the example message flow in Fig. 7.3.2.1-2, and according
to the semantics in RFC 7959 \[13\], the third line of the request
indicates, by \'B2\', the use of the \'Block2\' option in the request,
and whereby the notation \'1/0/6\' correspond to the triplet
\[NUM/M/SZX\]. The NUM field represents the block number of the payload
requested for return in the response (\'1\', \'5\' and \'6\' in this
example), the M bit has no meaning and is set to zero, and SZX = 6 is a
variable for use in computing the actual block size for use in
block-wise transfer, as given by 2^(SZX\ +\ 4)^, or 1024 bytes. Due to
the use of the Confirmable (CON) message in the request with message ID
as shown inside the bracket \[ \], reliability is ensured for the
associated UDP transport by the returned ACK message, with the same
Message ID, in which the requested resource is piggybacked.

#### 7.3.2.2 Option 4: Block request for repair data after broadcast transmission of only repair symbols

In the example as shown below in Figure 7.3.2.2-1, only repair symbols
are sent in the broadcast delivery of the file object. As in the
previous case, a 6.7 Kbyte file is broadcast to (IoT) UEs, the BM-SC
applies AL-FEC in the transmission of the file object, and the encoded
repair symbols are sent as a sequence of ALC/ FLUTE packets, each with
payload size of 1024 bytes.

Figure 7.3.2.2-1: MBMS download delivery of 6.7-kByte file employing
256-byte FEC symbols carried in FLUTE packets with payload size of 1024
bytes; sending of repair symbols only

In this example, it can be seen that FEC symbols which map logically to
Blocks 1, 5, 6 and 7 were not received, resulting in the loss of repair
symbols with ESIs (Encoded Symbol IDs) 4-7 and 20-31. Similar to the
previous example, it is assumed that eleven additional symbols are
needed to enable full file recovery, but since only repair symbols were
transmitted/received, file recovery can be achieved at the UE by
acquiring any eleven source symbols, ensured to be distinct from the
already-received repair symbols. In this case, it would the simplest for
the MBMS client, acting as the CoAP client, to request the first eleven
source symbols, i.e., the initial 2048 bytes of the file stored in the
repair server. In other words, the UE will employ CoAP\'s Block2 option
to request, via the GET method, block-wise transfer by the server of the
first three 1024-byte blocks (Blocks 0, 1 and 2), from the repair
server, as shown in Figure 7.3.2.2-2.

Figure 7.3.2.2-2: Block-wise transfer request and response for retrieval
of FEC symbols contained in Blocks 0, 1 and 2 at repair server

#### 7.3.2.3 Comparison of Block Request based File Repair Options

The Option 3 vs. Option 4 methods for block request based file repair,
as described in Clauses 7.3.2.1 and 7.3.2.2, bear resemblance to the
broadcast delivery of source and repair symbols vs. repair symbols only
methodologies, respectively, and associated unicast procedures for
byte-range based file repair as specified in 3GPP TS 26.346. Broadcast
transmission of source and repair symbols is shown below in Fig.
7.3.2.3-1, and broadcast transmission of only the repair symbols is
shown in Fig. 7.3.2.3-2.

![](media/image22.png){width="3.113888888888889in"
height="1.6145833333333333in"}

Figure 7.3.2.3-1: Broadcast delivery of source and repair symbols

Figure 7.3.2.3-2: Broadcast delivery of repair symbols only

The Block options (\'Block1\' and \'Block2\' as defined in RFC 7959
\[3\] and \[13\]) enable the repair server to be stateless, i.e. it does
not maintain state on what the client has previously retrieved, nor is
it aware of the status of the file repair process -- e.g., when the
client has finished, whether the client has decided to abort the file
repair procedure (for example, due to change in the ETag value of the
file resource), etc. Complexity of server operation in support of file
repair requests from the UE is the same, regardless of whether the
client is retrieving contiguous or non-contiguous blocks, or the
relative position of the requested repair data within the source file
stored at the server (for example, at the beginning or near the end of
the file, or somewhere in between). The reason being that the server is
handling the request/response for one block at a time, and it maintains
no state information on prior transactions.

On the other hand, broadcast transmission of only repair symbols makes
the MBMS client\'s processing task a little easier, as it need not track
which source symbols are missing in generating request for that specific
set, which would be required if source symbols were broadcast. However,
the client still has to make two separate CoAP requests, as done in
Option 3. Another potential advantage of repair-only broadcast, as
compared to broadcast of source symbols, is the expected better caching
efficiency (higher \"hit ratio\') in case that proxy caches are employed
in the unicast network, since every client that performs file repair can
be designed to request repair data (as contiguous symbols) starting with
the very first CoAP Block of the source file.

### 7.3.3 Solution evaluation

The following points are observed from four solutions described in
clauses 7.3.1 and 7.3.2.

\- The Option 1 requires that the CoAP server (i.e. File Repair server)
understands the request range using defined keywords included in the
Uri-query from the CoAP client (i.e. IoT UE). The CoAP client can
request arbitrary byte range(s), i.e., a single range or multiple
ranges.

\- The Option 2 is similar to the Option 1. In addition, this option
requires the registration with IANA for the new CoAP option *Range*.

\- The Options 3 and 4 avoid the need for file repair servers with an
understanding of defined keywords included in the Uri-query as with the
Options 1 and 2. The Options 3 and 4 work with the requested byte-range
having 2^(SZX\ +\ 4)^ discrete values and the maximum requested range is
1024 octets since the SZX field occupies three-bit unsigned integer and
the value 7 for SZX is reserved.

7.4 Binary data formats
-----------------------

### 7.4.0 General

MBMS protocols, codecs and procedures often use XML as a format for
exchanging metadata (e.g. FDT, service announcement). However, the use
of XML stack can be costly for IoT devices, especially for low-end IoT
profile. Binary data formats may be more appropriate for IoT devices to
exchange metadata. One can define a particular binary format for each
specific purpose (e.g. FDT, service announcement, reception report).
However, it is desirable to have a common binary format for all
procedures, formats in the context of MBMS IoT.

### 7.4.1 Efficient Extensible Interchange or Efficient XML Exchange (EXI)

EXI is a way for one system to send to another system a highly
compressed sequence of parse events. The recipient can build data
structures directly from the parse events without having to reconstitute
a textual representation (such as a JSON file, an XML file, JavaScript,
HTML and so forth) \[14\]. It was developed by W3C\'s Efficient
Extensible Interchange Working Group. EXI provides multiple benefits as
follows (non exhaustive list):

\- EXI provides better compression than other XML compression
techniques, and can deliver compression ratios of up to 100 to 1 (Figure
7.4.5.2-1) \[15\];

\- Using EXI format reduces the verbosity of XML documents as well as
the cost of parsing;

\- When using EXI, XML parsers consume EXI directly. XML applications,
such as XML Schema validators and XSLT processors, will process the EXI
exactly as they\'ve always processed XML, i.e., no changes to the XML
applications are required and XML applications are completely unaware
that the format of the data is binary, not text (Figure 7.4.1-2);

\- EXI format specification does not make particular assumption about
the platform architecture;

\- EXI was designed to integrate well into the XML stack, neither
duplicating nor requiring changes to functionality at other layers in
the XML stack.

Figure 7.4.1-1 shows the diagram which uses EXI to exchange data between
sender and receiver.

![](media/image24.png){width="3.3625in" height="2.5388888888888888in"}

Figure 7.4.1-1: Data exchange using EXI \[15\]

Figure 7.4.1-2 shows the interaction between EXI, XML parser and XML
application. The parser converts the EXI to an XML infoset and XML
applications operate on the infoset. Thus, the applications are unaware
that EXI is being used.

![](media/image25.png){width="2.5236111111111112in"
height="1.8743055555555554in"}

Figure 7.4.1-2: Interaction between EXI, XML parser and XML application
\[15\]

EXI defines two types of encoding: schema-less and schema-informed. The
schema-less encoding is generated directly from the XML data and can be
decoded by any EXI entity without any prior knowledge about the data.
The schema-informed encoding assumes that the two EXI processors share
an XML Schema before actual encoding and decoding can take place. In
schema-informed, the available schema information is used to improve
compactness and performance.

### 7.4.2 Well-known binary formats

A number of well-known binary formats for representing data are
available such as ASN.1 \[16\], Thrift \[17\], Protobuf \[18\].

The Abstract Syntax Notation One (ASN.1) is a well-known binary format
used in many applications, especially in telecommunications (3G, LTE).
The notation describes data structures for representing, encoding,
transmitting, and decoding data. Data structures transfer syntax can be
encoded using different encoding rules, providing schema notation even
for representing XML in binary form - XER (XML Encoding Rules). The
standard ASN.1 encoding rules include:

\- Distinguished Encoding Rules (DER)

\- Basic Encoding Rules (BER)

\- Canonical Encoding Rules (CER)

\- XML Encoding Rules (XER)

\- Canonical XML Encoding Rules (CXER)

\- Extended XML Encoding Rules (E-XER)

\- Packed Encoding Rules (PER, unaligned: UPER, canonical: CPER)

\- Octet Encoding Rules (OER, canonical: COER)

\- JSON Encoding Rules (JER)

\- Generic String Encoding Rules (GSER)

Unaligned PER is commonly used in 3GPP cellular technologies such as
UMTS (3G) or LTE (4G) for protocols like RANAP, NBAP or RRC \[19\]. It
is noted that the bit ordering is defined and automatically handled by
the ASN.1 PER compiler generated code.

Thrift is an interface definition language and binary communication
protocol that is used to define and create services for numerous
languages. Thrift is used as a remote procedure call (RPC) framework and
was developed at Facebook. Although developed at Facebook, it is now an
open source project in the Apache Software Foundation.

The Protocol Buffers (Protobuf) is a method of serializing structured
data. It is useful in developing programs to communicate with each other
over a wire or for storing data. Protobuf were initially developed at
Google to address the problem of large number of requests and responses
to/from the index server. This protocol uses binary encoding which makes
serialized data more compact. The design goals for Protobuf emphasized
simplicity and performance. In particular, it was designed to be smaller
and faster than XML.

Table 7.4.2-1 shows the comparison between these binary formats \[20\].

Table 7.4.2-1: Comparison of binary formats

  ------------------------ -------------------------- ------------------------ -------------------
                           Binary formats                                      
                           ASN.1                      Thrift                   Protobuf
  Licence                  Open source                Open source              Open source
  Language compatibility   Java, C++, C, Python\...   C++, Java, Python, PHP   Java, C++, Python
  Parsing speed            Fast                       Medium                   Fast
  Memory usage             Low                        Medium                   Medium
  Debugging complexity     High                       Low                      Medium
  Implementation           Medium                     Medium                   Low
  Documentation            Very good                  Less than good           Very good
  ------------------------ -------------------------- ------------------------ -------------------

NOTE: The implementation indicates the implementation complexity. ASN.1
demands external (third-party) tool for reading encoded message, and it
is more complex to deploy \[20\]. Protobuf has some built-in features,
i.e. to String() method that returns human-readable representation of
message.

### 7.4.3 Ad-hoc binary format

Besides the well-known binary formats presented in clause 7.4.2 (ASN.1,
Thrift, Protobuf), one can define a customized binary format for a given
data structure requirement.

For instance, Figure 7.4.3-1 shows an example of an Ad-hoc binary format
for FDT.

<table>
<tbody>
<tr class="odd">
<td>Bits</td>
<td><blockquote>
<p>Number of Octets</p>
</blockquote></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>HET = 194</td>
<td>1</td>
<td>Header part</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>FLUTE Version = 1</td>
<td>FDT Instance ID</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FDT Instance ID continue</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Binary FDT Version = 1</td>
<td>Expires</td>
<td>Base-URL-1</td>
<td>Base-URL-2</td>
<td>FEC Information bit (NOTE 6)</td>
<td>1 (NOTE 5)</td>
<td>Binary FDT descriptor</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Length of FDT descriptor (NOTE 7)</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Content-type (NOTE 1)</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Length of Expires</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Expires</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Length of Base-URL-1</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Base-URL-1</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Length of Base-URL-2</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Base-URL-2</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FEC-OTI-FEC-Encoding-ID</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>FEC-OTI-Maximum-Source-Block-Length</td>
<td><p>2 or 4</p>
<p>(NOTE 2)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FEC-OTI-Encoding-Symbol-Length</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Length of FEC-OTI-Scheme-Specific-Info</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FEC-OTI-Scheme-Specific-Info</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Number of files (NOTE 3)</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Reserved bits for extension of FDT descriptor (NOTE 7)</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Length of the N<sup>th</sup> file (NOTE 4)</td>
<td>2</td>
<td>Binary FDT content</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Content Length</td>
<td>Content Type</td>
<td>Content MD5</td>
<td>FEC-OTI-FEC-Encoding-ID</td>
<td>FEC Information bit (NOTE 6)</td>
<td>mbms2012:Alternate-Content-Location-1</td>
<td>mbms2012:Alternate-Content-Location-2</td>
<td>mbms2012:File-ETag</td>
<td>1 (NOTE 5)</td>
<td></td>
</tr>
<tr class="even">
<td>Transport Object Identifier (TOI) of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Length of Content-location of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Content-location of the N<sup>th</sup> file</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Length of Content-Length of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Content-Length of the N<sup>th</sup> file</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Content-Type of the N<sup>th</sup> file</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Length of Content-MD5 of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Content-MD5 of the N<sup>th</sup> file</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>FEC-OTI-FEC-Encoding-ID of the N<sup>th</sup> file</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FEC-OTI-Maximum-Source-Block-Length of the N<sup>th</sup> file</td>
<td><p>2 or 4</p>
<p>(NOTE 2)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>FEC-OTI-Encoding-Symbol-Length of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FEC-OTI-Max-Number-of-Encoding-Symbols of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Length of FEC-OTI-Scheme-Specific-Info of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FEC-OTI-Scheme-Specific-Info of the N<sup>th</sup> file</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Length of mbms2012:Alternate-Content-Location-1 of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>mbms2012:Alternate-Content-Location-1 of the N<sup>th</sup> file</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Length of mbms2012:Alternate-Content-Location-2 of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>mbms2012:Alternate-Content-Location-2 of the N<sup>th</sup> file</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Length of mbms2012:File-ETag of the N<sup>th</sup> file</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>mbms2012:File-ETag</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Reserved bits for extension of the N<sup>th</sup> file (NOTE 4)</td>
<td>0-m</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Figure 7.4.3-1: Example of AD-hoc binary FDT Instance format

NOTE 1: Content-type of 8 bits could be sufficient for IoT applications.

NOTE 2: 2 octets for FEC Encoding IDs 0, 128, and 130; 4 octets for FEC
Encoding ID 129.

NOTE 3: A maximum of 255 files delivered in a single FLUTE session could
be sufficient since multiple FLUTE sessions are possible.

NOTE 4: If the length value of the N^th^ file in the binary FDT is
higher than the actual length, the reserved bit for extension are
present. The content and values of the extension fields are FFS.

NOTE 5: A list of flags indicates whether the element appears in the FDT
or N^th^ file. The value \'0\' indicates that the flag is not appeared,
the corresponding length and content fields of this flag are not
appeared in the binary FDT. The value \'1\' indicates that the flag is
present. The order of the flag content follows the order in the list of
flags. For the elements which have a specific length such as FEC related
information, there is no length field.

NOTE 6: The FEC Information bit is set to \'0\' if compact no-code FEC
is used. Otherwise, this flag is set to \'1\', the corresponding fields
(FEC-OTI-Maximum-Source-Block-Length, FEC-OTI-Encoding-Symbol-Length,
Length of FEC-OTI-Scheme-Specific-Info, FEC-OTI-Scheme-Specific-Info)
related to FEC are present.

NOTE 7: If the value of the length of FDT descriptor is higher than the
actual length, the reserved bits for extension are present. The content
and values of extension fields are FFS.

### 7.4.4 Key-Length-Value (KLV) format

Clause 7.4.3 presents the ad-hoc binary format where each data
representation requires a customized binary format. Another possible
solution is to use a special Key-Length-Value for all formats and
procedures for MBMS IoT. In this KLV format, each data type is
associated to a key value while the Length field indicates the actual
length of the Value field. For instance, one can define up to 255 keys
for MBMS IoT as shown in Table 7.4.4-1.

Table 7.4.4-1: Example table for KLV format

  ----- -------------------- -------- -------
  Key   Data type            Length   Value
  1     Content-Location     2        
  2     Content-Type         1        
  3     mbms2012:File-ETag   2        
  ...                                 
  255                                 
  ----- -------------------- -------- -------

This KLV solution can be considered as a subset of ASN.1 solution using
BER, PER or OER encoding rules.

### 7.4.5 Performance comparison of binary data formats

#### 7.4.5.1 General considerations

There are important aspects to consider when comparing different data
representation schemes \[24\]. Some of the most relevant are,

\- how are optional fields within messages handled, i.e., how is a
field\'s presence or absence represented,

\- possibility of future backward compatibility when extending a
message, i.e., adding of new mandatory or optional data fields,

\- byte alignment,

\- providing the functionality of data compression, for example variable
length representation of integers.

Table 7.4.5.1-1 show the properties of different schemes from the
general considerations \[24\]. The properties of ASN.1 UPER, Protobuf
and EXI are extracted from \[24\].

Table 7.4.5.1-1: Overview of basic properties for different binary
schemes

  ----------------------------- --------------------- ------------------- ------------------- -------------- ----------------------
                                ASN.1 UPER (NOTE 7)   Protobuf (NOTE 7)   EXI (NOTE 7)        KLV            Ad-hoc binary format
  Presence of optional fields   Encoded               Encoded             Encoded             Not encoded    Encoded (NOTE 4)
  Extendibility                 No (NOTE 1)           Yes                 Yes                 Yes (NOTE 3)   Yes (NOTE 5)
  Byte alignment (NOTE 6)       No (NOTE 2)           Yes                 No                  Yes            No
  Compression                   Yes                   Yes (byte blocks)   Yes (byte blocks)   Yes            Yes
  ----------------------------- --------------------- ------------------- ------------------- -------------- ----------------------

NOTE 1: Other ASN.1 encoding rules (e.g. BER) satisfy this property.

NOTE 2: The aligned PER encoding rule satisfies this property.

NOTE 3: The extendibility of KLV format is limited to the pre-defined
maximum number of keys (e.g. 255 keys if 8 bits are used).

NOTE 4: Optional fields are presented by a list of flags.

NOTE 5: If reserved bits for extension are used.

NOTE 6: Byte alignment indicates that the fields are aligned to 8-bit
octet boundaries by inserting padding bits.

NOTE 7: The assessment of ASN.1 UPER, Protobuf and EXI reflects the view
of the authors in \[24\].

#### 7.4.5.2 Performance comparison

Figure 7.4.5.2-1 shows better compactness of EXI compared to both XML
and ASN.1 PER \[22\]. However, the comparison between EXI and ASN.1 PER
in terms of processing efficiency is not shown in the evaluation
performed by W3C.

![](media/image26.png){width="5.334027777777778in"
height="3.6479166666666667in"}

Figure 7.4.5.2-1: EXI compactness compared to ASN.1 PER

NOTE 1: Whenever a schema is available, EXI uses the schema-informed for
the test cases \[22\].

Table 7.4.5.2-1 also confirms the better compactness of EXI compared to
ASN.1 PER \[23\]. In this evaluation, EXI uses schema-informed and
no-compression.

Table 7.4.5.2-1: Comparison in terms of compactness between XML, ASN.1
PER and EXI

  ----------- ----------------------- --------------------------- -------------- -------
              JTLM Data (360 bytes)   Location Data (103 bytes)                  
  Format      Size (bytes)            Ratio                       Size (bytes)   Ratio
  XML         360                     100%                        103            100%
  ASN.1 PER   105                     29%                         27             26%
  EXI         39                      11%                         17             17%
  ----------- ----------------------- --------------------------- -------------- -------

NOTE 2: The compactness performance of EXI may be different when
schema-less is used.

Table 7.4.5.2-2 shows the processing efficiency for both encoding and
decoding \[23\]. ASN.1 PER shows better processing efficiency with
Location Data (103 bytes).

Table 7.4.5.2-2: Comparison in terms of processing efficiency between
XML, ASN.1 PER and EXI

  ----------- -------- -------- -------- -------
              Encode   Decode            
  Format      TPS      Ratio    TPS      Ratio
  XML         15858    1        9216     1
  EXI         185029   x11.7    277409   x30.0
  ASN.1 PER   310862   x19.6    318419   x34.6
  ----------- -------- -------- -------- -------

NOTE 3: TPS stands for transactions per second.

The evaluation between Protobuf, EXI and ASN.1 UPER is performed in the
context of wireless Car-to-X communication \[24\]. The performance
metrics considered in this evaluation are:

\- Computation time

\- Memory footprint on computation

\- Encoded data length.

Tables 7.4.5.2-3 and 7.4.5.2-4 show the encoding and decoding
performance results for CAM (Cooperative Awareness Message) and DENM
(Decentralized Environmental Notification Message) messages with
Protobuf, ASN.1 UPER and EXI.

Table 7.4.5.2-3: Encoding performance results for CAMs and DENMs \[24\]

  ---------------- ------------ ------------ -------------- ------------ ------------ --------------
                   CAM          DENM                                                  
  Encoding type    Protobuf     ASN.1 UPER   EXI            Protobuf     ASN.1 UPER   EXI
  Heap / Stack     242 / 1864   66 / 3112    62656 / 210    126 / 1752   75 / 2792    61608 / 175
  Encoded length   165          41           64 (opt: 61)   114          43           52 (opt: 51)
  ---------------- ------------ ------------ -------------- ------------ ------------ --------------

Table 7.4.5.2-4: Memory related decoding performance results for CAMs
and DENMs \[24\]

  -------------------- ------------ ------------ ------------
                       Protobuf     ASN.1 UPER   EXI
  CAM: heap / stack    242 / 1800   370 / 2968   3850 / 210
  DENM: heap / stack   126 / 1624   816 / 2872   3630 / 135
  -------------------- ------------ ------------ ------------

NOTE 4: Size of encoded messages is one of the key parameters in the
evaluation in \[24\], data optimized schemes are used for EXI.

The following conclusions are drawn from the evaluation in \[24\]:

\- ASN.1 UPER outperforms Protobuf and EXI in terms of required encoding
delay and runtime (Figure 7.4.5.2-2).

\- EXI showed to be the most expensive in terms of memory footprint
(Tables 7.4.5.2-3 and 7.4.5.2-4).

\- ASN.1 UPER encoding performs better compared to EXI and Protobuf in
terms of encoding length for CAM and DENM messages (Tables 7.4.5.2-3 and
7.4.5.2-4).

In terms of runtime, binary encoding performs significantly better than
ASN.1 UPER in all studied cases (Figure 7.4.5.2-2).

![](media/image27.png){width="6.686805555555556in"
height="2.3520833333333333in"}

Figure 7.4.5.2-2: Encoding (left) and decoding (right) runtime
performance of ETSI ITS CAM, DENM and security envelope encoding on an
Intel Core i7 processor \[24\]

NOTE 5: Sec. 1w/o indicates security profile 1 for CAM message without
certificate. Sec. 1w indicates security profile 1 for CAM message with
certificate. Sec. 2 indicates security profile 2 for DENM message. Sec.
3 indicate security profile 3 for generic message.

NOTE 6: The binary format is specialized for CAM and DENM messages.

#### 7.4.5.3 Summary

The following conclusions are drawn from the performance comparison in
clause 7.4.5.2:

\- Binary data formats (e.g. EXI, ASN.1, Protobuf) significantly
outperform the XML data representation in terms of both compactness,
encoding/decoding processing efficiency and memory usage.

\- ASN.1 UPER is better than EXI in terms of processing efficiency and
memory footprint \[24\].

\- ASN.1 PER is better than EXI in terms of processing efficiency
\[23\].

\- EXI is better than ASN.1 (UPER or PER) in terms of compactness in the
evaluation performed by W3C. In the evaluation performed by \[24\],
ASN.1 UPER performs better than EXI for CAM and DENM messages in terms
of encoded data length.

\- Binary encoding specialized for CAM and DENM messages significantly
better than ASN.1 UPER and EXI in terms of run time.

#### 7.4.5.4 Recommendation

According to previous results, it is recommended to use ASN.1 PER as
basis for binary format for IoT.

7.5 Solution for announcement during wake-up periods
----------------------------------------------------

This solution addresses the recommended requirement in clause 4.2.2. IoT
devices use eDRX (Extended Discontinuous Reception) and PSM (Power
Saving Mode) to save battery consumption. When a software/firmware
update is required, the service announcement using continuous/carousel
broadcast delivery of SACH (Service Announcement Channel) may not be
efficient from the network perspective since IoT devices are not
expected to be awake throughout the day, but only infrequently.
Furthermore, they do not wake-up at the same time and more importantly,
they are not reachable while being in power saving mode. This solution
proposes to inform the IoT devices about a newly scheduled download
delivery session during their wake-up periods when the devices are
reachable.

For initially unplanned data delivery use case described in clause 4.2,
when a new MBMS schedule containing the new software/firmware update for
IoT devices becomes available, the network will send a message to inform
the IoT UEs about the new schedule when they wake up, but before
returning to power saving mode.

Such message to inform IoT UEs about a new MBMS schedule can either/

\- Indicate the time at which service announcement based on SACH will be
sent;

\- Contain the service announcement including the Schedule Description
if the size is small.

The time interval from when a new file delivery schedule is announced to
when the actual MBMS file delivery session as announced by that schedule
will start is larger than the maximum PSM period of all IoT devices.
This constraint ensures that all IoT devices are informed about the new
file delivery schedule.

According to 3GPP TS 23.682 clause 4.5.4, a UE using PSM is available
for mobile terminating services only for the period of an Active Time
after a mobile originated event like data transfer or signalling, e.g.
after a periodic TAU/RAU procedure (Tracking Area Update/Routing Area
Update). Figure 7.5-1 shows an example when the IoT UE \#1 has available
data to send to the network and the network takes advantage of this
reachable period to inform the UE about a newly scheduled download
delivery session. The IoT UE \#2 receives an announcement later when it
wakes up to send data. Due to some reasons (e.g. lost connectivity), the
IoT UE \#3 does not wake up periodically to send data. The IOT UE \#3
wakes up to update its tracking area due to the expiration of TAU timer,
it also receives the announcement from the network.

![](media/image28.png){width="5.636805555555555in" height="3.29375in"}

Figure 7.5-1: Inform about a new schedule during UE wake-up periods

NOTE 1: Waking up due to expiration of TAU timer is not common for
battery-constrained IoT applications. In practice, to optimize the
battery usage in IoT devices, periodic TAU timer is configured to be
longer than the periodic time when the devices wake up to send data to
the network.

The network may use PUT CoAP method with Content-Format option to
deliver the information about a new MBMS schedule (Figure 7.5-2). In
this example, ID 42 is used to indicate an octet-stream data type.

![](media/image29.png){width="6.2131944444444445in"
height="1.1944444444444444in"}

Figure 7.5-2: Example use of CoAP PUT method to inform about a new
schedule

NOTE 2: The message content is out of scope of this solution and is
addressed in other solutions.

NOTE 3: If the content carried in PUT method is larger than the maximum
CoAP message size preferred by IoT UEs, block-wise transfer as described
in RFC 7959 can be applied.

7.6 Solution for announcement with critical data delivery
---------------------------------------------------------

This solution addresses the recommended requirement in clause 4.3.2. The
solution for service announcement when a critical software/firmware
update is required is as follows:

\- When a new MBMS schedule containing a critical software/firmware
update for IoT devices becomes available, the network will send a
message to inform the IoT UEs about the new schedule when they are
reachable;

\- The network may schedule multiple critical delivery sessions where
the time between two consecutive delivery sessions is considered as
critical interval;

\- The time interval from when a critical file delivery schedule is
announced to when the first MBMS file delivery session as announced by
that schedule will start can be shorter than the minimum PSM period of
all IoT devices.

The IoT UEs using PSM and/or eDRX can be reachable in the following
possible cases:

\- In connected mode if the IoT UEs have just sent data to the network;

\- In active state after PSM;

\- In idle state and listen for paging (DRX or eDRX)

NOTE 1: Other possible cases where the IoT devices are reachable are out
of scope of this study.

NOTE 2: The IoT UEs which do not use neither PSM nor eDRX follows the
paging procedures as regular UEs.

NOTE 3: The details how the network pages the IoT devices are out of
scope of this study.

Similar to the solution in clause 7.5, a message to inform IoT UEs about
a critical MBMS schedule can either

\- Indicate the time at which service announcement based on SACH will be
sent;

\- Contain the service announcement including the Schedule Description.

> Figure 7.6-1 shows an example when the IoT UE \#1 wakes up and has
> available data to send to the network. Since the IoT UE \#1 has
> switched to Idle state at the time a new MBMS schedule has been
> created and is sent over the MBMS bearer (as represented by the
> left-most vertical dashed line), the network will page the device and
> inform the UE about a newly scheduled download delivery session for
> critical data. The IoT UE \#2 receives the announcement later when it
> wakes up to send data. Both IoT UE \#1 and \#2 wake up at the
> scheduled time (First repetition of broadcast delivery of files
> according to the schedule) to receive the software/firmware update
> from the network. The IoT UE \#3 wakes up after the first repetition
> of broadcast delivery of files is completed, it also receives the
> announcement from the network for the next download delivery session
> (Second repetition of broadcast delivery of files according to the
> schedule). During the next wake up periods of IoT UE \#1 or \#2, the
> network does not inform about the download delivery session since they
> already received the software/firmware update. The process continues
> until all IoT devices receive a critical software/firmware update and
> have appropriate action (e.g. successful update).

![](media/image30.png){width="6.060416666666667in"
height="3.571527777777778in"}

Figure 7.6-1: Announcement of broadcast schedule for a critical download
delivery session during UE wake-up from PSM to send data and subsequent
broadcast delivery/reception of the associated file

7.7 Solution for reception report procedures
--------------------------------------------

This solution addresses the recommended requirements in clause 4.1.2.
There are 4 *reportType defined in 3GPP TS 26.346, Table 7.7-1 shows the
supported reportType for IoT devices.*

Table 7.7-1: supported *reportType* for IoT devices

  ------------ --------------
  reportType   IoT profiles
  Rack-IoT     Yes (NOTE 1)
  StaR         No (NOTE 2)
  StaR-all     No (NOTE 2)
  StaR-only    Yes (NOTE 2)
  ------------ --------------

NOTE 1: *reportType* Rack-IoT is an extension of Rack (defined in *3GPP
TS 26.346)* in order to fulfil the requirements for IoT. According to
3GPP TS 26.346 clause 9.4.3, \"*The samplePercentage attribute is
optional and behaviour shall default to 100 (%) when it is not present.
The samplePercentage attribute may be used with StaR, StaR-only and
StaR-all, but shall not be used with RAck*\". *For IoT devices, this
samplePercentage attribute can be useful to save battery consumption in
the device for non-critical software delivery. For critical software
delivery, this attribute will be set to 100.*

NOTE 2: StaR-only might not be desirable for Low-end IoT profile.
However, StaR-only can be useful for High-end IoT profile while other
statistical report variants are not necessary.

Table 7.7-1 show the fields that could be contained in the reception
report message for RAck-IoT *reportType*.

Table 7.7-1: Fields contained in binary reception report message for
RAck-IoT *reportType*

  ----------------------------- -------------------------------
  Field name                    Presence (Mandatory/Optional)
  IoT ID (NOTE 1)               M
  Number of files (NOTE 2)      M
  Status of the file (NOTE 3)   M
  ID of the file (NOTE 4)       M
  ----------------------------- -------------------------------

NOTE 3: IoT ID can be *clientId or* *deviceId, or both*. According to
clause 9.4.6 of TS 26.346, the *deviceId* attribute is a unique
identifier for the receiver device, e.g. an IMEI of the UE while the
*clientId* attribute is unique identifier for the receiver, e.g. an
MSISDN of the UE. For IoT applications, the *deviceId* attribute could
be more important than *clientId*.

NOTE 4: A maximum of 255 files delivered in a single FLUTE session could
be sufficient since multiple FLUTE sessions are possible.

NOTE 5: The status value addresses the recommended requirement where the
3GPP system supports a mechanism to acknowledge a successful reception
and action required (e.g. successful file update). For example, the
status value is set to \'0\' for \"acknowledged\", \'1\' for
\"acknowledged with successful action\", \'2\' for \"acknowledged with
unsuccessful action\". Other values are reserved.

NOTE 6: ID of the file can be *fileURI*, *Content-MD5* or File-Etag.
*fileURI* could be mandatory while *Content-MD5* and File-Etag could be
optional.

A proposal of ASN.1 PER definition for reception report message for
RAck-IoT type is depicted as follows

\-- ASN1START

MBMSIoT-ReceptionReport-Message-RAck-IoT ::= SEQUENCE {

identifier IoT-ID-IEs,

fileReporting SEQUENCE (SIZE(1..255)) OF
ReceptionReport-File-RAck-IoT-IEs,

locationType ENUMERATED{cgi, ecgi, sai, \...} OPTIONAL,

nonCriticalExtension ReceptionReportMessage-RAck-IoT-Extension-IEs
OPTIONAL

}

IoT-ID-IEs ::= SEQUENCE {

deviceId OCTET STRING (SIZE(1..255)),

clientId OCTET STRING (SIZE(1..255)) OPTIONAL

}

ReceptionReportMessage-RAck-IoT-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

ReceptionReport-File-RAck-IoT-IEs ::= SEQUENCE {

status ENUMERATED {acknowledged, acknowledgedAndSuccessfulAction,
acknowledgedAndUnsuccessfulAction, \...},

identifier File-ID-IEs,

nonCriticalExtension ReceptionRepot-File-RAck-IoT-Extension-IEs OPTIONAL

}

File-ID-IEs ::= SEQUENCE {

fileURI OCTET STRING (SIZE(1..255)),

contentMD5 BIT STRING (SIZE(128)) OPTIONAL,

fileEtag OCTET STRING (SIZE(1..255)) OPTIONAL

}

ReceptionRepot-File-RAck-IoT-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

\-- ASN1STOP

NOTE 7: ASN.1 defines multiple character string types (e.g. BMPString,
IA5String, GeneralString, GraphicString, NumericString, PrintableString,
TeletexString, UniversalString, UTF8String, VideotexString,
VisibleString, etc.). The encoding does not matter for Low-end IoT
devices without user interface, OCTET STRING type can represent an
identifier, a URL or URI.

NOTE 8: The string size is limited to 255 in order to occupy only 1
octet for the field description.

In 3GPP TS 26.346, reception report is sent in a single HTTP POST
request carrying XML formatted metadata for each reported received
content (file). However, IoT devices, especially low-end profile, might
not have HTTP and TCP stacks. Figure 7.7-2 shows the solution for
reception report using POST CoAP method. In this example, ID 42 for
Content-Format is used to indicate an octet-stream data type.

![](media/image31.png){width="5.896527777777778in"
height="1.4256944444444444in"}

Figure 7.7-2: Example use of CoAP POST method to send reception report

NOTE 9: If the content carried in POST method is larger than the maximum
CoAP message size preferred by the CoAP client and server, block-wise
transfer as described in RFC 7959 can be applied.

7.8 Solution for service announcement procedures
------------------------------------------------

### 7.8.1 Unicast delivery of service announcement using CoAP

3GPP TS 26.346 clause 5.2.5 specifies the user service announcement over
point-to-point push bearers where SMS or HTTP push bearers are used for
delivery of metadata envelope and metadata fragments. As indicated in
the clause 6.1, a CoAP based solution for Interactive Announcement
Function instead of HTTP could be more appropriate. The solutions in the
clauses 7.5 and 7.6 indicate that a unicast delivery of service
announcement using CoAP is possible. The unicast delivery of service
announcement using CoAP could be used for the use cases described in
clauses 4.2 and 4.3.

NOTE: The broadcast schedule using SACH could be used for the use case 3
described in clause 4.3.

### 7.8.2 Service announcement profiles for IoT devices

The Service announcement for IoT devices might be kept as small and
simple as possible. The profiling for IoT applications is based on the
MBMS User Service Discovery / Announcement Profile 1a specified in the
Annex L.2 of 3GPP TS 26.346.

3GPP TS 2.346 clause 11.1 specifies the MBMS metadata envelope. To
reduce the service announcement size (i.e. reduce battery consumption),
the software update for each Low-end IoT device type (e.g. smart
water-metering, smart electric-metering) might be carried in different
MBMS sessions. Thus, a metadata envelope based on ASN.1 PER binary
encoding for Low-end profile contains only one USBD fragment, one
Session Description fragment, one Schedule Description fragment, and
optionally one Associated Delivery Procedure Description (ADPD)
fragment. A USBD contains only one instance of USD fragment.

Clause 11.1.4 of 3GPP TS 26.346 indicates that a metadata fragment can
be embedded or referenced within a metadata envelope. For IoT
applications, it\'s desirable to use the embedded metadata fragments
within the metadata envelope.

Table 7.8.1-1 shows the list of supported metadata fragment in a
metadata envelope.

Table 7.8.1-1: List of metadata fragments in a metadata envelope.

  ----------------------------------------------------- ------------------------------------- ----------------------------------
  Metadata fragment                                     **Recommended for Low-end profile**   Recommended for High-end profile
  USBD                                                  M                                     M
  Session Description                                   M                                     M
  Schedule Description                                  M                                     M
  Associated Delivery Procedure Description             O                                     O
  MPD                                                   No                                    O
  Initialization Segment Description (ISD)              No                                    O
  NOTE: MPD and ISD are not required for IoT devices.                                         
  ----------------------------------------------------- ------------------------------------- ----------------------------------

Clause L.2.4 in 3GPP TS 26.346 specifies that the *validFrom* and
*validUntil* attributes in each *item* of the metadata envelope are
identical for all fragments of a given MBMS User Service. Therefore, a
single (*validFrom*, *validUntil*) attribute couple for a metadata
envelope in binary format is required for IoT devices to reduce the size
(i.e. reduce battery consumption). The time is expressed as UTC
timestamp.

Clause L.2.5 in 3GPP TS 26.346 specifies the list of supported
attributes and elements for a USBD fragment. Table 7.8.1-2 shows the
profiling of USBD fragment for IoT devices.

Table 7.8.1-2: List of supported attributes and elements for USBD
fragment used by IoT service providers

+----------------------+----------------------+----------------------+
| Attribute or element | Recommended for      | MBMS profile 1a in   |
|                      | Low-end IoT category | Annex L.2 3GPP TS    |
|                      | profile              | 26.346               |
+----------------------+----------------------+----------------------+
| bundleDescript       | No (NOTE 1)          | M                    |
| ion.sv:schemaVersion |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescription.us | M                    | M                    |
| erServiceDescription |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDesc           | M                    | M                    |
| ription.userServiceD |                      |                      |
| escription.serviceId |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescriptio     | O                    | M                    |
| n.userServiceDescrip |                      |                      |
| tion.r7:serviceClass |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescripti      | M                    | M                    |
| on.userServiceDescri |                      |                      |
| ption.deliveryMethod |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescription.   | M                    | M                    |
| userServiceDescripti |                      |                      |
| on.deliveryMethod\@s |                      |                      |
| essionDescriptionURI |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDesc           | M                    | M                    |
| ription.userServiceD |                      |                      |
| escription.deliveryM |                      |                      |
| ethod\@associatedPro |                      |                      |
| cedureDescriptionURI |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescri         | O                    | O                    |
| ption.userServiceDes |                      |                      |
| cription.deliveryMet |                      |                      |
| hod\@accessPointName |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDe             | No (NOTE 1)          | M                    |
| scription.userServic |                      |                      |
| eDescription.deliver |                      |                      |
| yMethod.sv:delimiter |                      |                      |
+----------------------+----------------------+----------------------+
| b                    | M (NOTE 2)           | M                    |
| undleDescription.use |                      |                      |
| rServiceDescription. |                      |                      |
| requiredCapabilities |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDes            | M (NOTE 2)           | M                    |
| cription.userService |                      |                      |
| Description.required |                      |                      |
| Capabilities.feature |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescri         | M                    | M                    |
| ption.userServiceDes |                      |                      |
| cription.r9:schedule |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescrip        | No (NOTE 1)          | M                    |
| tion.userServiceDesc |                      |                      |
| ription.sv:delimiter |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescri         | No (NOTE 3)          | M                    |
| ption.userServiceDes |                      |                      |
| cription.r9:mediaPre |                      |                      |
| sentationDescription |                      |                      |
+----------------------+----------------------+----------------------+
| bundl                | No (NOTE 3)          | O                    |
| eDescription.userSer |                      |                      |
| viceDescription.name |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescriptio     | No (NOTE 3)          | O                    |
| n.userServiceDescrip |                      |                      |
| tion.serviceLanguage |                      |                      |
+----------------------+----------------------+----------------------+
| bundleDescription.us | O                    | O                    |
| erServiceDescription |                      |                      |
| .r9:availabilityInfo |                      |                      |
+----------------------+----------------------+----------------------+
| bund                 | O                    | O                    |
| leDescription.userSe |                      |                      |
| rviceDescription.r9: |                      |                      |
| availabilityInfo.inf |                      |                      |
| oBinding.serviceArea |                      |                      |
+----------------------+----------------------+----------------------+
| bundleD              | O                    | O                    |
| escription.userServi |                      |                      |
| ceDescription.r9:ava |                      |                      |
| ilabilityInfo.infoBi |                      |                      |
| nding.radioFrequency |                      |                      |
+----------------------+----------------------+----------------------+
| NOTE 1: The          |                      |                      |
| *schemaVersion* and  |                      |                      |
| *delimiter* elements |                      |                      |
| are only applied for |                      |                      |
| XML data format.     |                      |                      |
|                      |                      |                      |
| NOTE 2: \"MBMS User  |                      |                      |
| Service Discovery /  |                      |                      |
| Announcement Profile |                      |                      |
| 1a\" specifies the   |                      |                      |
| value \'22\' to the  |                      |                      |
| *feature* element.   |                      |                      |
|                      |                      |                      |
| NOTE 3: The          |                      |                      |
| *r9:mediaPrese       |                      |                      |
| ntationDescription*, |                      |                      |
| *name* and           |                      |                      |
| *serviceLanguage*    |                      |                      |
| elements are not     |                      |                      |
| necessary for IoT    |                      |                      |
| devices.             |                      |                      |
+----------------------+----------------------+----------------------+

NOTE 1: The list of non-supported attributes and elements specified in
the clause L.2.5 of 3GPP TS 26.346 are not supported for IoT devices.

Clause L.2.6 in 3GPP TS 26.346 specifies the list of supported
attributes and elements for Schedule Description fragment. Table 7.8.1-3
shows the list of supported attributes and elements of the Schedule
Description fragment for IoT devices.

Table 7.8.1-3: List of supported attributes and elements for Schedule
Description fragment used by IoT service providers

  ------------------------------------------------------------------------ ---------------------------------------------- ---------------------------------------------
  Attribute or element                                                     Recommended for Low-end IoT category profile   MBMS profile 1a in Annex L.2 3GPP TS 26.346
  scheduleDescription.sv:schemaVersion                                     No                                             M
  scheduleDescription.serviceSchedule.sessionSchedule                      M                                              M
  scheduleDescription.serviceSchedule.sessionSchedule.start                M                                              M
  scheduleDescription.serviceSchedule.sessionSchedule.stop                 M                                              M
  scheduleDescription.serviceSchedule.sessionSchedule.index                M                                              M
  scheduleDescription.serviceSchedule.sessionScheduleOverride              O                                              O
  scheduleDescription.serviceSchedule.sessionScheduleOverride\@index       O                                              O
  scheduleDescription.serviceSchedule.sessionScheduleOverride\@cancelled   O                                              O
  scheduleDescription.serviceSchedule.fileSchedule                         O                                              O
  scheduleDescription.serviceSchedule.fileSchedule.fileURI                 O                                              O
  scheduleDescription.serviceSchedule.fileSchedule.fileURI\@cancelled      O                                              O
  scheduleDescription.serviceSchedule.deliveryInfo                         O                                              O
  scheduleDescription.serviceSchedule.deliveryInfo\@start                  O                                              O
  scheduleDescription.serviceSchedule.deliveryInfo\@stop                   O                                              O
  NOTE: The schemaVersion is only applied for XML data format.                                                            
  ------------------------------------------------------------------------ ---------------------------------------------- ---------------------------------------------

NOTE 2: The list of non-supported attributes and elements specified in
the clause L.2.6 of 3GPP TS 26.346 are not supported for IoT devices.
The time is expressed in UTC timestamp.

Clause L.2.7 in 3GPP TS 26.346 specifies the list of supported
attributes and elements for Associated Delivery Procedure Description
fragment. Table 7.8.1-4 shows the list of supported attributes and
elements of the ADPD fragment for IoT devices.

Table 7.8.1-4: List of supported attributes and elements for ADPD
fragment for IoT service providers

  --------------------------------------------------------------------------- ---------------------------------------------- ---------------------------------------------
  Attribute or element                                                        Recommended for Low-end IoT category profile   MBMS profile 1a in Annex L.2 3GPP TS 26.346
  associatedProcedureDescription.postFileRepair                               O                                              O
  associatedProcedureDescription.postFileRepair\@offsetTime                   O                                              O
  associatedProcedureDescription.postFileRepair\@randomTimePeriod             O                                              O
  associatedProcedureDescription.postFileRepair.serviceURI                    O                                              O
  associatedProcedureDescription.postReceptionReport                          O                                              O
  associatedProcedureDescription.postReceptionReport\@offsetTime              O                                              O
  associatedProcedureDescription.postReceptionReport\@randomTimePeriod        O                                              O
  associatedProcedureDescription.postReceptionReport\@samplePercentage        O                                              O
  associatedProcedureDescription.postReceptionReport\@forceTimeIndependence   O                                              O
  associatedProcedureDescription.postReceptionReport\@reportType              O                                              O
  associatedProcedureDescription.postReceptionReport.serviceURI               O                                              O
  --------------------------------------------------------------------------- ---------------------------------------------- ---------------------------------------------

NOTE 3: The list of non-supported attributes and elements specified in
the clause L.2.7 of 3GPP TS 26.346 are not supported for IoT devices.

The parameters for Session Description fragment of an MBMS download
session is specified in the clause 7.3.2 of 3GPP TS 26.346. The
non-recognized, non-supported or invalid parameters are ignored by the
IoT devices.

Clause 7.3.2 of TS 26.346 describes the SDP for Download Delivery
Method, Table 7.8.1-5 shows the fields and attributes applied for IoT
applications when SDP is embedded in the service announcement.

Table 7.8.1-5: List of supported attributes and elements for SDP

+----------------------+----------------------+----------------------+
| Parameters           | **Presence           | Maximum number of    |
|                      | (                    | occurrences          |
|                      | Mandatory/Optional** |                      |
|                      |                      |                      |
|                      | **Or No)**           |                      |
+----------------------+----------------------+----------------------+
| The sender IP        | M                    | 1                    |
| address              |                      |                      |
+----------------------+----------------------+----------------------+
| The number of        | No (Note 1)          | 0                    |
| channels in the      |                      |                      |
| session              |                      |                      |
+----------------------+----------------------+----------------------+
| The destination IP   | M                    | 1                    |
| address and port     |                      |                      |
| number for each      |                      |                      |
| channel in the       |                      |                      |
| session per media    |                      |                      |
+----------------------+----------------------+----------------------+
| The Transport        | M                    | 1                    |
| Session Identifier   |                      |                      |
| (TSI) of the session |                      |                      |
+----------------------+----------------------+----------------------+
| The start time and   | M                    | 1                    |
| end time of the      |                      |                      |
| session              |                      |                      |
+----------------------+----------------------+----------------------+
| The protocol ID      | No (Note 2)          | 0                    |
| (i.e. FLUTE/UDP)     |                      |                      |
+----------------------+----------------------+----------------------+
| Media type(s) and    | No                   | 0                    |
| fmt-list             |                      |                      |
+----------------------+----------------------+----------------------+
| Data rate using      | No                   | 0                    |
| existing SDP         |                      |                      |
| bandwidth modifiers  |                      |                      |
+----------------------+----------------------+----------------------+
| Mode of MBMS bearer  | No (Note 3)          | 0                    |
| per media            |                      |                      |
+----------------------+----------------------+----------------------+
| FEC capabilities and | O                    | 0                    |
| related parameters   |                      |                      |
+----------------------+----------------------+----------------------+
| Service-language(s)  | No                   | 0                    |
| per media            |                      |                      |
+----------------------+----------------------+----------------------+
| QoE Metrics (as      | No                   | 0                    |
| defined in           |                      |                      |
| sub-clauses 8.3.2.1  |                      |                      |
| and 8.4)             |                      |                      |
+----------------------+----------------------+----------------------+
| NOTE 1: The clause   |                      |                      |
| 7.3.2.2 of TS 26.346 |                      |                      |
| indicates \"Only one |                      |                      |
| FLUTE channel is     |                      |                      |
| allowed per FLUTE    |                      |                      |
| session in the       |                      |                      |
| present document and |                      |                      |
| thus there is no     |                      |                      |
| further need for a   |                      |                      |
| descriptor of the    |                      |                      |
| number of            |                      |                      |
| channels\".          |                      |                      |
|                      |                      |                      |
| NOTE 2: It is not    |                      |                      |
| necessary to         |                      |                      |
| describe this        |                      |                      |
| element as FLUTE is  |                      |                      |
| the unique protocol  |                      |                      |
| for MBMS IoT         |                      |                      |
| applications.        |                      |                      |
|                      |                      |                      |
| NOTE 3: Since        |                      |                      |
| resource-constrained |                      |                      |
| IoT devices (e.g.    |                      |                      |
| NB-IoT) use SC-PTM   |                      |                      |
| delivery mode, it\'s |                      |                      |
| not necessary to     |                      |                      |
| describe the mode of |                      |                      |
| MBMS bearer for IoT  |                      |                      |
| applications.        |                      |                      |
+----------------------+----------------------+----------------------+

An example of ASN.1 PER definition for Service Announcement is depicted
as follows. This definition uses the embedded mode for all metadata
fragments except the Session Description fragment. The Session
Description fragment is referenced by the SDP file.

\-- ASN1START

MBMSIoT-ServiceAnnouncement ::= SEQUENCE {

validFrom UTCTime,

vaidUntil UTCTime,

usbd USBD-Fragment-IEs,

sessionDescription OCTET STRING (SIZE(1..255)),

scheduleDescription ScheduleDescription-Fragment-IEs,

adpd ADPD-Fragment-IEs OPTIONAL,

nonCriticalExtension ServiceAnnouncement-Extension-IEs OPTIONAL

}

ServiceAnnouncement-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

USBD-Fragment-IEs ::= SEQUENCE {

serviceID OCTET STRING (SIZE(1..255)),

r7ServiceClass OCTET STRING (SIZE(1..255))OPTIONAL,

deliveryMethod DeliveryMethod-IEs,

requiredCapabilities INTEGER(0..255),

availabilityInfo AvailabilityInfo-IEs OPTIONAL,

nonCriticalExtension USBD-Fragment-Extension-IEs OPTIONAL

}

USBD-Fragment-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

DeliveryMethod-IEs ::= SEQUENCE {

sessionDescriptionURI OCTET STRING (SIZE(1..255)),

associatedProcedureDescriptionURI OCTET STRING (SIZE(1..255)),

accessPointName OCTET STRING (SIZE(1..50)) OPTIONAL,

nonCriticalExtension DeliveryMethod-Extension-IEs OPTIONAL

}

DeliveryMethod-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

AvailabilityInfo-IEs ::= SEQUENCE {

serviceArea INTEGER (0..65535) OPTIONAL,

radioFrequency INTEGER (0..4294967295) OPTIONAL,

nonCriticalExtension AvailabilityInfo-Extension-IEs OPTIONAL

}

AvailabilityInfo-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

ScheduleDescription-Fragment-IEs ::= SEQUENCE {

serviceSchedule SEQUENCE (SIZE(1..8)) OF ServiceSchedule-IEs

}

ServiceSchedule-IEs ::= SEQUENCE {

sessionSchedule SEQUENCE (SIZE(0..255)) OF
SessionScheduleDescription-IEs OPTIONAL,

fileSchedule SEQUENCE (SIZE(0..255)) OF FileScheduleDescription-IEs ,

sessionScheduleOverride SessionScheduleOverride-IEs OPTIONAL,

nonCriticalExtension ServiceSchedule-Extension-IEs OPTIONAL

}

ServiceSchedule-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

SessionScheduleDescription-IEs ::= SEQUENCE {

start UTCTime,

stop UTCTime,

index INTEGER (0..4294967295),

nonCriticalExtension SessionScheduleDescription-Extension-IEs OPTIONAL

}

SessionScheduleDescription-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

FileScheduleDescription-IEs ::= SEQUENCE {

fileURI FileURI-IEs OPTIONAL,

deliveryInfo DeliveryInfo-IEs OPTIONAL,

nonCriticalExtension FileScheduleDescription-Extension-IEs OPTIONAL

}

FileScheduleDescription-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

FileURI-IEs ::= SEQUENCE {

fileURI OCTET STRING (SIZE(1..255)),

cancelled BOOLEAN,

nonCriticalExtension FileURI-Extension-IEs OPTIONAL

}

FileURI-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

SessionScheduleOverride-IEs ::= SEQUENCE {

index INTEGER (0..4294967295),

cancelled BOOLEAN,

nonCriticalExtension SessionScheduleOverride-Extension-IEs OPTIONAL

}

SessionScheduleOverride-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

DeliveryInfo-IEs ::= SEQUENCE {

start UTCTime OPTIONAL,

stop UTCTime OPTIONAL,

nonCriticalExtension DeliveryInfo-Extension-IEs OPTIONAL

}

DeliveryInfo-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

ADPD-Fragment-IEs ::= SEQUENCE {

postFileRepair PostFileRepair-IEs OPTIONAL,

postReceptionReport PostReceptionReport-IEs OPTIONAL

}

PostFileRepair-IEs ::= SEQUENCE {

offsetTime INTEGER (0..4294967295) OPTIONAL,

randomPeriodTime INTEGER (0..4294967295) OPTIONAL,

serviceURI OCTET STRING (SIZE(1..255)) OPTIONAL,

nonCriticalExtension PostFileRepair-Extension-IEs OPTIONAL

}

PostFileRepair-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

PostReceptionReport-IEs ::= SEQUENCE {

offsetTime INTEGER (0..4294967295) OPTIONAL,

randomPeriodTime INTEGER (0..4294967295) OPTIONAL,

samplePercentage INTEGER(0..100) OPTIONAL,

forceTimeIndependence BOOLEAN OPTIONAL,

reportType INTEGER(0..3) OPTIONAL,

serviceURI OCTET STRING (SIZE(1..255)) OPTIONAL,

nonCriticalExtension PostReceptionReport-Extension-IEs OPTIONAL

}

PostReceptionReport-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

\-- ASN1STOP

NOTE 4: It is not necessary to have the compression (e.g. gzip) in SA
file using ASN.1 PER definition.

NOTE 5: The maximum URL/URI length for IoT applications could be limited
to 255.

NOTE 6: *ServiceArea* element type is unsigned short. *RadioFrequency*
element type is unsigned integer.

NOTE 7: If an ASN.1 PER IE contains less than 7 elements, adding a
nonCriticalExtension element does not occupy an additional octet for the
bitmap element descriptor which describes the presence or absence of the
elements. It\'s up to the implementation to handle or ignore the
nonCriticalExtension elements.

An example of ASN.1 PER definition for Service Announcement is depicted
as follows when all metadata fragments are embedded including the
Session Description fragment. In this example, the necessary elements
and attributes in the FDT instance are also embedded in the Service
Announcement.

\-- ASN1START

MBMSIoT-ServiceAnnouncement ::= SEQUENCE {

validFrom UTCTime,

vaidUntil UTCTime,

usbd USBD-Fragment-IEs,

sessionDescription SessionDescription-Fragment-IEs,

scheduleDescription ScheduleDescription-Fragment-IEs,

adpd ADPD-Fragment-IEs OPTIONAL,

nonCriticalExtension ServiceAnnouncement-Extension-IEs OPTIONAL

}

ServiceAnnouncement-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

USBD-Fragment-IEs ::= SEQUENCE {

serviceID OCTET STRING (SIZE(1..255)),

r7ServiceClass OCTET STRING (SIZE(1..255))OPTIONAL,

deliveryMethod DeliveryMethod-IEs,

requiredCapabilities INTEGER(0..255),

availabilityInfo AvailabilityInfo-IEs OPTIONAL,

nonCriticalExtension USBD-Fragment-Extension-IEs OPTIONAL

}

USBD-Fragment-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

DeliveryMethod-IEs ::= SEQUENCE {

sessionDescriptionURI OCTET STRING (SIZE(1..255)),

associatedProcedureDescriptionURI OCTET STRING (SIZE(1..255)),

accessPointName OCTET STRING (SIZE(1..50)) OPTIONAL,

nonCriticalExtension DeliveryMethod-Extension-IEs OPTIONAL

}

DeliveryMethod-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

AvailabilityInfo-IEs ::= SEQUENCE {

serviceArea INTEGER (0..65535) OPTIONAL,

radioFrequency INTEGER (0..4294967295) OPTIONAL,

nonCriticalExtension AvailabilityInfo-Extension-IEs OPTIONAL

}

AvailabilityInfo-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

SessionDescription-Fragment-IEs ::= SEQUENCE {

senderIPAddress IP-Address-IE,

tmgi TMGI-IE,

ipDestinationAddress IP-Address-IE,

destinationPortNumber INTEGER (0..65535),

tsi BIT STRING (SIZE(16)),

startTime UTCTime OPTIONAL,

endTime UTCTime OPTIONAL,

fecRedundancyLevel INTEGER (0..100) OPTIONAL,

nonCriticalExtension SessionDescription-Fragment-Extension-IEs OPTIONAL

}

IP-Address-IE ::= CHOICE {

ipv4 BIT STRING (SIZE(32)),

ipv6 BIT STRING (SIZE(128))

}

TMGI-IE ::= SEQUENCE {

plmn-Id PLMN-Identity,

serviceId OCTET STRING (SIZE (3))

}

PLMN-Identity ::= SEQUENCE {

mcc MCC OPTIONAL,

mnc MNC

}

MCC ::= SEQUENCE (SIZE(3)) OF MCC-MNC-Digit

MNC ::= SEQUENCE (SIZE(3)) OF MCC-MNC-Digit

MCC-MNC-Digit ::= INTEGER(0..9)

SessionDescription-Fragment-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

ScheduleDescription-Fragment-IEs ::= SEQUENCE {

serviceSchedule SEQUENCE (SIZE(1..8)) OF ServiceSchedule-IEs

}

ServiceSchedule-IEs ::= SEQUENCE {

sessionSchedule SEQUENCE (SIZE(0..255)) OF
SessionScheduleDescription-IEs OPTIONAL,

fileSchedule SEQUENCE (SIZE(0..255)) OF FileScheduleDescription-IEs ,

sessionScheduleOverride SessionScheduleOverride-IEs OPTIONAL,

nonCriticalExtension ServiceSchedule-Extension-IEs OPTIONAL

}

ServiceSchedule-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

SessionScheduleDescription-IEs ::= SEQUENCE {

start UTCTime,

stop UTCTime,

index INTEGER (0..4294967295),

nonCriticalExtension SessionScheduleDescription-Extension-IEs OPTIONAL

}

SessionScheduleDescription-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

FileScheduleDescription-IEs ::= SEQUENCE {

fileURI FileURI-IEs OPTIONAL,

deliveryInfo DeliveryInfo-IEs OPTIONAL,

expires INTEGER (0..4294967295) OPTIONAL,

baseURL1 OCTET STRING(SIZE(1..255)) OPTIONAL,

baseURL2 OCTET STRING(SIZE(1..255)) OPTIONAL,

nonCriticalExtension FileScheduleDescription-Extension-IEs OPTIONAL

}

FileScheduleDescription-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

FileURI-IEs ::= SEQUENCE {

fileURI OCTET STRING (SIZE(1..255)),

toi BIT STRING (SIZE(16)),

contentLength INTEGER (0..4294967295) OPTIONAL,

contentMD5 OCTET STRING (SIZE(1..255)) OPTIONAL,

mbms2012AlternateContentLocation1 OCTET STRING(SIZE(1..255)) OPTIONAL,

mbms2012FileEtag OCTET STRING(SIZE(1..255)) OPTIONAL,

cancelled BOOLEAN,

nonCriticalExtension FileURI-Extension-IEs OPTIONAL

}

FileURI-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

SessionScheduleOverride-IEs ::= SEQUENCE {

index INTEGER (0..4294967295),

cancelled BOOLEAN,

nonCriticalExtension SessionScheduleOverride-Extension-IEs OPTIONAL

}

SessionScheduleOverride-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

DeliveryInfo-IEs ::= SEQUENCE {

start UTCTime OPTIONAL,

stop UTCTime OPTIONAL,

nonCriticalExtension DeliveryInfo-Extension-IEs OPTIONAL

}

DeliveryInfo-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

ADPD-Fragment-IEs ::= SEQUENCE {

postFileRepair PostFileRepair-IEs OPTIONAL,

postReceptionReport PostReceptionReport-IEs OPTIONAL

}

PostFileRepair-IEs ::= SEQUENCE {

offsetTime INTEGER (0..4294967295) OPTIONAL,

randomPeriodTime INTEGER (0..4294967295) OPTIONAL,

serviceURI OCTET STRING (SIZE(1..255)) OPTIONAL,

nonCriticalExtension PostFileRepair-Extension-IEs OPTIONAL

}

PostFileRepair-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

PostReceptionReport-IEs ::= SEQUENCE {

offsetTime INTEGER (0..4294967295) OPTIONAL,

randomPeriodTime INTEGER (0..4294967295) OPTIONAL,

samplePercentage INTEGER(0..100) OPTIONAL,

forceTimeIndependence BOOLEAN OPTIONAL,

reportType INTEGER(0..3) OPTIONAL,

serviceURI OCTET STRING (SIZE(1..255)) OPTIONAL,

nonCriticalExtension PostReceptionReport-Extension-IEs OPTIONAL

}

PostReceptionReport-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

\-- ASN1STOP

NOTE 8: It is not necessary to have the compression (e.g. gzip) in SA
file using ASN.1 PER definition.

NOTE 9: The maximum URL/URI length for IoT applications could be limited
to 255.

NOTE 10: *ServiceArea* element type is unsigned short. *RadioFrequency*
element type is unsigned integer.

NOTE 11: The \"Content-Location\", \"Content-Length\", \"Content-MD5\",
\"Alternative-Content-Location-1\", and \"File-Etag\" elements in the
FDT instance are described in the FileURI-IEs. The
\"Alternative-Content-Location-2\" element is not necessary as the
\"Alternative-Content-Location-1\" element could be enough.

NOTE 12: The \"Expires\" element in the FDT instance is described in the
FileScheduleDescription-IEs.

NOTE 13: If the *fecRedundancyLevel* element is present, the Raptor FEC
scheme is applied. The FEC related parameters
(\"FEC-OTI-FEC-Encoding-ID\", \"FEC-OTI-Maximum-Source-Block-Length\",
\"FEC-OTI-Encoding-Symbol-Length\", \"FEC-OTI-Scheme-Specific-Info\",
\"FEC-OTI-Max-Number-of-Encoding-Symbols\") could take a fixed value,
they are not present in this example.

NOTE 14: A strict convention for file name extension could be used to
recognize the \"Content-type\" (e.g. file.bin), this attribute is not
present in this example.

NOTE 15: If an ASN.1 PER IE contains less than 7 elements, adding a
nonCriticalExtension element does not occupy an additional octet for the
element bitmap descriptor which describes the presence or absence of the
elements. It\'s up to the implementation to handle or ignore the
nonCriticalExtension elements.

7.9 ASN.1 PER binary FDT instance definition
--------------------------------------------

ASN.1 PER is recommended as a binary data format for IoT devices. An
example of ASN.1 PER definition for binary FDT instance is depicted as
follows:

\-- ASN1START

MBMSIoT-BinaryFDT-Instance ::= SEQUENCE {

headerExtensionType INTEGER (0..255),

version BIT STRING (SIZE(8)),

fdtInstanceID BIT STRING (SIZE(20)),

contentType INTEGER (0..255),

expires INTEGER (0..4294967295) OPTIONAL,

baseURL1 OCTET STRING(SIZE(1..255)) OPTIONAL,

baseURL2 OCTET STRING(SIZE(1..255)) OPTIONAL,

fecInformation FECInformation-IEs OPTIONAL,

fileDescription SEQUENCE(SIZE(1..255)) OF FileDescription-IEs,

nonCriticalExtension BinaryFDT-Instance-Extension-IEs OPTIONAL

}

BinaryFDT-Instance-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

FileDescription-IEs ::= SEQUENCE {

transportObjectIdentifier INTEGER (0..65535),

contentLocation OCTET STRING(SIZE(1..255)),

contentLength INTEGER (0..4294967295) OPTIONAL,

contentType INTEGER (0..255) OPTIONAL,

contentMD5 OCTET STRING (SIZE(1..255)) OPTIONAL,

fecInformation FECInformation-IEs,

transferLength INTEGER (0..4294967295) OPTIONAL,

mbms2012AlternateContentLocation1 OCTET STRING(SIZE(1..255)) OPTIONAL,

mbms2012AlternateContentLocation2 OCTET STRING(SIZE(1..255)) OPTIONAL,

mbms2012FileEtag OCTET STRING(SIZE(1..255)) OPTIONAL,

mbms-IoT-mbms007CacheControl CacheControl-IEs OPTIONAL,

nonCriticalExtension FileDescription-Extension-IEs OPTIONAL

}

FileDescription-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

CacheControl-IEs ::= CHOICE {

cachingDirective BIT STRING (SIZE(2)),

expires INTEGER (0..4294967295)

}

FECInformation-IEs ::= SEQUENCE {

fecEncodingID INTEGER (0..255),

maximumSourceBLockLength INTEGER (0..4294967295),

encodingSymbolLength INTEGER (0..4294967295),

schemeSpecificInfo OCTET STRING (SIZE(1..255)),

nonCriticalExtension FECInformation-Extension-IEs OPTIONAL

}

FECInformation-Extension-IEs ::= SEQUENCE {

lateNonCriticalExtension OCTET STRING OPTIONAL,

nonCriticalExtension SEQUENCE {} OPTIONAL

}

\-- ASN1STOP

NOTE 1: In *mbms-IoT-Version*, the4 significant bits indicate the FLUTE
version (RFC 3926), the 4 least significant bits indicate the binary FDT
version.

NOTE 2: Content type of 8 bits could be sufficient for IoT applications.

NOTE 3: The *Expires* attribute defined in RFC 3926 and TS 26.346 is
string. The *Expires* attribute defined for ASN.1 PER is unsigned
integer to reduce the message size.

NOTE 4: The maximum URL/URI length for IoT applications could be limited
to 255.

NOTE 5: A maximum of 255 files delivered in a single FLUTE session could
be sufficient since multiple FLUTE sessions are possible.

NOTE 6: TOI is defined as positive integer in RFC 3926 and TS 26.346. 16
bits could be sufficient for IoT applications.

NOTE 7: OCTET STRING is used to replace base64binary.

NOTE 8: FEC Encoding ID is defined in 8 bits in RFC 3926.

NOTE 9: Clause 7.2.13 of 3GPP TS 26.346 defines three caching
directives: no-cache, max-stale, and Expires. The two caching directives
\"no-cache\" and \"max-stale\" are represented by a BIT STRING to avoid
decoding ambiguity as they have the same BOOLEAN data type. The first
significant bit represents the caching directive, the least significant
bit indicates the value of caching directive (e.g. \"11\" for
\"no-cache\" having TRUE value, \"10\" for \"no-cache\" having FALSE
value, \"01\" for \"max-stale\" having TRUE value, and \"00\" for
\"max-stale\" having FALSE value).

8 Conclusions
=============

During the study on MBMS usage for IoT applications, multiple solutions
have been provided for simplified procedures and protocols to address
the software update for IoT devices using MBMS User Services.

\- Different use cases where the network wants to deliver the software
update to IoT devices have been identified.

\- An analysis on IoT device capabilities has been performed. IoT
devices having constrained resources (e.g. battery, computing, memory,
storage) are then classified into two categories for MBMS reception:
Low-end and High-end.

\- A simplified profile for MBMS file download delivery method has been
documented. The subsequent simplified procedures for this profile (e.g.
file repair, reception report, service announcement) have been also
documented.

Instead of using HTTP, CoAP is used for message exchange between IoT
devices and server (e.g. file repair and reception report messages). As
per the evaluation and comparison of binary data formats (e.g. EXI,
ASN.1, Protobuf) in clause 7.4, it is recommended to use ASN.1 PER as
binary format for IoT applications using MBMS User Services. As a
result, the following messages and procedures could use the ASN.1 PER
definition if necessary:

\- FDT instance;

\- Reception report message format for both RAck-IoT and StaR-only
*reportType;*

\- Fields and attributes in the SDP embedded in the service
announcement;

\- Service announcement using embedded mode.

Depending on the complexity and requirements, a solution for High-end
category profile could use either XML or ASN.1 PER. A solution for
Low-end category profile could exclusively use ASN.1 PER for data
format. In addition, the fields and attributes in the FDT instance and
SDP could be embedded in the service announcement if more stringent
resource constrains are required for Low-end category profile.

######### Annex A: Change history

  -------------------- ------------- ----------- -------- --------- --------- ----------------------------------------- -----------------
  **Change history**                                                                                                    
  **Date**             **Meeting**   **TDoc**    **CR**   **Rev**   **Cat**   **Subject/Comment**                       **New version**
  2017-12              78            SP-170830                                Presented to TSG SA\#78 for information   1.0.0
  2018-09              81            SP-180660                                Presented to TSG SA\#81 for approval      2.0.0
  2018-09              81                                                     Approved at TSG SA\#81                    16.0.0
  -------------------- ------------- ----------- -------- --------- --------- ----------------------------------------- -----------------
